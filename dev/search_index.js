var documenterSearchIndex = {"docs":
[{"location":"formatting/#Formatting","page":"Formatter integration","title":"Formatting","text":"JETLS provides document formatting support through integration with external formatting tools. By default, Runic.jl is used, but you can configure alternative formatters or use custom formatting executables.","category":"section"},{"location":"formatting/#Features","page":"Formatter integration","title":"Features","text":"Document formatting: Format entire Julia files\nRange formatting: Format selected code regions (Runic and custom formatters only)\nProgress notifications: Visual feedback during formatting operations for clients that support work done progress","category":"section"},{"location":"formatting/#Prerequisites","page":"Formatter integration","title":"Prerequisites","text":"JETLS supports preset formatters as well as custom formatting executables. For preset formatters, install your preferred formatter and ensure it's available in your system PATH:\n\nRunic (default):\njulia -e 'using Pkg; Pkg.Apps.add(\"Runic\")'\nJuliaFormatter (requires v2.2.0 or higher):\njulia -e 'using Pkg; Pkg.Apps.add(\"JuliaFormatter\")'\n\nNote that you need to manually make ~/.julia/bin available on the PATH environment for the formatter executables to be accessible. See https://pkgdocs.julialang.org/dev/apps/ for the details.\n\nFor custom formatters, no installation is required—simply configure the path to your executable in .JETLSConfig.toml (see the custom formatter section below).","category":"section"},{"location":"formatting/#Formatter-configuration","page":"Formatter integration","title":"Formatter configuration","text":"Configure the formatter using either a .JETLSConfig.toml file in your project root or via LSP configuration (see How to configure JETLS for details). The configuration supports three options:","category":"section"},{"location":"formatting/#Preset-\"Runic\"-(default)","page":"Formatter integration","title":"Preset \"Runic\" (default)","text":"formatter = \"Runic\"\n\nIn this case, JETLS will look for the runic executable and use it to perform formatting.\n\nThis is the default setting and doesn't require explicit configuration. Runic supports both document and range formatting.","category":"section"},{"location":"formatting/#Preset-\"JuliaFormatter\"","page":"Formatter integration","title":"Preset \"JuliaFormatter\"","text":"formatter = \"JuliaFormatter\"\n\nIn this case, JETLS will look for the jlfmt executable and use it to perform formatting.\n\nIf a .JuliaFormatter.toml configuration file is found in your project, jlfmt will use those settings. Otherwise, it uses default settings with formatting options provided by the editor client (such as tab size) when available.\n\nwarning: Warning\nNote that JuliaFormatter currently, as of v2.2.0, only supports full document formatting, not range formatting.","category":"section"},{"location":"formatting/#Custom-formatter","page":"Formatter integration","title":"Custom formatter","text":"[formatter.custom]\nexecutable = \"/path/to/custom-formatter\"\nexecutable_range = \"/path/to/custom-range-formatter\"\n\nCustom formatters should accept Julia code via stdin and output formatted code to stdout, following the same interface as runic:\n\nexecutable: Command for full document formatting. The formatter should read the entire Julia source code from stdin, format it completely, and write the formatted result to stdout. The exit code should be 0 on success.\nexecutable_range: Command for range formatting. The formatter should accept a --lines=START:END argument to format only the specified line range. It should read the entire document code from stdin and write the entire document code to stdout with only the specified region formatted. The rest of the document must remain unchanged.","category":"section"},{"location":"formatting/#Troubleshooting","page":"Formatter integration","title":"Troubleshooting","text":"If you see an error about the formatter not being found:\n\nEnsure you've installed the formatter as described above\nCheck that the formatter executable is in your system PATH by running which runic or which jlfmt\nFor custom formatters, verify the executable path specified in your settings\nRestart your editor to ensure it picks up the updated PATH or configuration","category":"section"},{"location":"launching/#Launching-JETLS","page":"Launching","title":"Launching JETLS","text":"This guide explains how to launch the JETLS language server using the jetls executable and describes the available communication channels.","category":"section"},{"location":"launching/#Using-the-jetls-executable","page":"Launching","title":"Using the jetls executable","text":"The JETLS server is launched using the jetls executable, which is the main entry point of launching JETLS that can be installed as an executable app via Pkg.jl:\n\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\n\nYou can run jetls with various options to configure how the server communicates with clients.\n\njetls --help\n\nJETLS - A Julia language server with runtime-aware static analysis,\npowered by JET.jl, JuliaSyntax.jl, and JuliaLowering.jl\n\nUsage: jetls [OPTIONS]\n\nCommunication channel options (choose one, default: --stdio):\n  --stdio                     Use standard input/output (not recommended)\n  --pipe-connect=<path>       Connect to client's Unix domain socket/named pipe\n  --pipe-listen=<path>        Listen on Unix domain socket/named pipe\n  --socket=<port>             Listen on TCP socket\n\nOptions:\n  --clientProcessId=<pid>     Monitor client process (enables crash detection)\n  --help, -h                  Show this help message\n\nExamples:\n  jetls --pipe-listen=/tmp/jetls.sock\n  jetls --pipe-connect=/tmp/jetls.sock --clientProcessId=12345\n  jetls --socket=8080\n  jetls --threads=auto -- --clientProcessId=12345","category":"section"},{"location":"launching/#Communication-channels","page":"Launching","title":"Communication channels","text":"The jetls executable supports multiple communication channels between the client and server. Choose based on your environment and requirements:","category":"section"},{"location":"launching/#pipe-connect-/-pipe-listen-(Unix-domain-socket-/-named-pipe)","page":"Launching","title":"pipe-connect / pipe-listen (Unix domain socket / named pipe)","text":"Advantages: Complete isolation from stdin/stdout, preventing protocol corruption; fastest for local communication\nBest for: Local development, Remote SSH, WSL\nLimitations: Not suitable for cross-container communication\nNote: Client is responsible for socket file cleanup in both modes\n\nThe jetls executable provides two pipe modes:","category":"section"},{"location":"launching/#pipe-connect","page":"Launching","title":"pipe-connect","text":"Server connects to a client-created socket. This is the mode used by the jetls-client VSCode extension and is generally easier to implement:\n\nClient creates and listens on the socket first\nClient spawns the server process\nServer immediately connects to the client's socket\nNo stdout monitoring required - simpler client implementation\n\nExample:\n\njetls --pipe-connect=/tmp/jetls.sock","category":"section"},{"location":"launching/#pipe-listen","page":"Launching","title":"pipe-listen","text":"Server creates and listens on a socket, then waits for the client to connect. This is the traditional LSP server mode:\n\nClient spawns the server process\nServer creates socket and prints <JETLS-PIPE-READY>/tmp/jetls.sock</JETLS-PIPE-READY> to stdout\nClient must monitor stdout for the readiness notification\nClient connects to the socket after receiving notification\n\nExample:\n\njetls --pipe-listen=/tmp/jetls.sock","category":"section"},{"location":"launching/#socket-(TCP)","page":"Launching","title":"socket (TCP)","text":"Advantages: Complete isolation from stdin/stdout, preventing protocol corruption; works across network boundaries; supports port forwarding\nBest for: Manual remote connection across different machines (without VSCode Remote); shared server accessed by multiple developers\nLimitations: May require firewall configuration; potentially less secure than local alternatives\n\nExample:\n\njetls --socket=7777\n\nThe server will print <JETLS-PORT>7777</JETLS-PORT> to stdout once it starts listening. This is especially useful when using --socket=0 for automatic port assignment, as the actual port number will be announced:\n\njetls --socket=0\n# Output: <JETLS-PORT>54321</JETLS-PORT>  (actual port assigned by OS)\n\nUse with SSH port forwarding to connect from a different machine:\n\nssh -L 8080:localhost:8080 user@remote\n# Then connect your local client to localhost:8080","category":"section"},{"location":"launching/#stdio","page":"Launching","title":"stdio","text":"Advantages: Simplest setup; maximum compatibility; works everywhere\nBest for: Dev containers; environments where pipe doesn't work\nLimitations: Risk of protocol corruption if any code writes to stdin/stdout\n\nExample:\n\njetls --stdio\n# or simply\njetls\n\nwarning: Warning\nWhen using stdio mode, any println(stdout, ...) in your code or dependency packages may corrupt the LSP protocol and break the connection. Prefer pipe or socket modes when possible.","category":"section"},{"location":"launching/#Client-process-monitoring","page":"Launching","title":"Client process monitoring","text":"The --clientProcessId option enables the server to monitor the client process for crash detection, where the server periodically checks whether the specified process is still alive. If the client crashes or terminates unexpectedly, the server will automatically shut down, ensuring proper cleanup even when the client cannot execute the normal LSP shutdown sequence.\n\nnote: Note\nWhen specified via command line, the process ID should match the processId field that the client sends in the LSP initialize request parameters.","category":"section"},{"location":"diagnostic/#Diagnostic","page":"Diagnostic","title":"Diagnostic","text":"JETLS reports various diagnostic messages (errors, warnings, hints) to help you catch potential issues in your Julia code. Each diagnostic has a unique code that identifies its category and type.\n\nThis document describes all available diagnostic codes, their meanings, default severity levels, and how to configure them to match your project's needs.","category":"section"},{"location":"diagnostic/#diagnostic-code","page":"Diagnostic","title":"Diagnostic codes","text":"JETLS reports diagnostics using hierarchical codes in the format \"category/kind\", following the LSP specification. This structure allows fine-grained control over which diagnostics to show and at what severity level through configuration.\n\nAll available diagnostic codes are listed below. Each category (e.g., syntax/*, lowering/*) contains one or more specific diagnostic codes:\n\nPages = [\"diagnostic.md\"]\nDepth = 3:4","category":"section"},{"location":"diagnostic/#diagnostic-severity","page":"Diagnostic","title":"Diagnostic severity levels","text":"Each diagnostic has a severity level that indicates how serious the issue is. JETLS supports four severity levels defined by the LSP specification:\n\nError (1): Critical issues that prevent code from working correctly. Most LSP clients display these with red underlines and error markers.\nWarning (2): Potential problems that should be reviewed. Typically shown with yellow/orange underlines and warning markers.\nInformation (3): Informational messages about code that may benefit from attention. Often displayed with blue underlines or subtle markers.\nHint (4): Suggestions for improvements or best practices. Usually shown with the least intrusive visual indicators.\n\nHow diagnostics are displayed depends on your LSP client (VS Code, Neovim, etc.), but most clients use color-coded underlines and gutter markers that correspond to these severity levels.\n\nYou can change the severity of any diagnostic by configuring diagnostic section. Additionally, JETLS supports disabling diagnostics entirely using the special severity value \"off\" (or 0).","category":"section"},{"location":"diagnostic/#diagnostic-reference","page":"Diagnostic","title":"Diagnostic reference","text":"This section provides detailed explanations for each diagnostic code. For every diagnostic, you'll find:\n\nA description of what the diagnostic detects\nIts default severity level\nCode examples demonstrating when the diagnostic is reported\nExample diagnostic messages (shown in code comments)\n\nHere is a summary table of the diagnostics explained in this section:\n\nCode Default Severity Description\nsyntax/parse-error Error Syntax parsing errors detected by JuliaSyntax.jl\nlowering/error Error General lowering errors\nlowering/macro-expansion-error Error Errors during macro expansion\nlowering/unused-argument Information Function arguments that are never used\nlowering/unused-local Information Local variables that are assigned but never read\ntoplevel/error Error Errors during code loading (missing deps, type failures, etc.)\ninference/undef-global-var Warning References to undefined global variables\ninference/undef-local-var Information/Warning References to undefined local variables\ntestrunner/test-failure Error Test failures from TestRunner integration","category":"section"},{"location":"diagnostic/#diagnostic/syntax","page":"Diagnostic","title":"Syntax diagnostic (syntax/*)","text":"","category":"section"},{"location":"diagnostic/#diagnostic/syntax/parse-error","page":"Diagnostic","title":"Syntax parse error (syntax/parse-error)","text":"Default severity: Error\n\nSyntax parsing errors detected by JuliaSyntax.jl. These indicate invalid Julia syntax that prevents the code from being parsed.\n\nExample:\n\nfunction parse_error(x)\n    println(x  # Expected `)` or `,` (JETLS syntax/parse-error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/lowering","page":"Diagnostic","title":"Lowering diagnostic (lowering/*)","text":"Lowering diagnostic is detected during Julia's lowering phase, which transforms parsed syntax into a simpler intermediate representation.","category":"section"},{"location":"diagnostic/#diagnostic/lowering/error","page":"Diagnostic","title":"Lowering error (lowering/error)","text":"Default severity: Error\n\nGeneral lowering errors that don't fit into more specific categories.\n\nExample:\n\nfunction lowering_error(x)\n    $(x)  # `$` expression outside string or quote block (JETLS lowering/error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/lowering/macro-expansion-error","page":"Diagnostic","title":"Macro expansion error (lowering/macro-expansion-error)","text":"Default severity: Error\n\nErrors that occur when expanding macros during the lowering phase.\n\nExample:\n\nfunction macro_expand_error()\n    @undefined_macro ex  # Macro name `@undefined_macro` not found (JETLS lowering/macro-expansion-error)\nend\n\nErrors that occur during actual macro expansion are also reported:\n\nmacro myinline(ex)\n    Meta.isexpr(ex, :function) || error(\"Expected long function definition\")\n    return :(@inline $ex)\nend\n@myinline callsin(x) = sin(x)  # Error expanding macro\n                               # Expected long function definition (JETLS lowering/macro-expansion-error)","category":"section"},{"location":"diagnostic/#diagnostic/lowering/unused-argument","page":"Diagnostic","title":"Unused argument (lowering/unused-argument)","text":"Default severity: Information\n\nFunction arguments that are declared but never used in the function body.\n\nExample:\n\nfunction unused_argument(x, y)  # Unused argument `y` (JETLS lowering/unused-argument)\n    return x + 1\nend","category":"section"},{"location":"diagnostic/#diagnostic/lowering/unused-local","page":"Diagnostic","title":"Unused local variable (lowering/unused-local)","text":"Default severity: Information\n\nLocal variables that are assigned but never read.\n\nExample:\n\nfunction unused_local()\n    x = 10  # Unused local binding `x` (JETLS lowering/unused-local)\n    return println(10)\nend","category":"section"},{"location":"diagnostic/#toplevel-diagnostic","page":"Diagnostic","title":"Top-level diagnostic (toplevel/*)","text":"Top-level diagnostic are reported by JETLS's full analysis feature, which runs when you save a file. To prevent excessive analysis on frequent saves, JETLS uses a debounce mechanism. See the [full_analysis] debounce configuration documentation to adjust the debounce period.","category":"section"},{"location":"diagnostic/#diagnostic/toplevel/error","page":"Diagnostic","title":"Top-level error (toplevel/error)","text":"Default severity: Error\n\nErrors that occur when JETLS loads your code for analysis. This diagnostic is commonly reported in several scenarios:\n\nMissing package dependencies (the most frequent cause)\nType definition failures\nReferences to undefined names at the top level\nOther errors during module evaluation\n\nExamples:\n\nstruct ToplevelError  # UndefVarError: `Unexisting` not defined in `JETLS`\n                      # Suggestion: check for spelling errors or missing imports. (JETLS toplevel/error)\n    x::Unexisting\nend\n\nusing UnexistingPkg  # Package JETLS does not have UnexistingPkg in its dependencies:\n                     # - You may have a partially installed environment. Try `Pkg.instantiate()`\n                     # to ensure all packages in the environment are installed.\n                     # - Or, if you have JETLS checked out for development and have\n                     # added UnexistingPkg as a dependency but haven't updated your primary\n                     # environment's manifest file, try `Pkg.resolve()`.\n                     # - Otherwise you may need to report an issue with JETLS (JETLS toplevel/error)\n\nThese errors prevent JETLS from fully analyzing your code, which means Inference diagnostic will not be available until the top-level errors are resolved. To fix these errors, ensure your package environment is properly set up by running Pkg.instantiate() in your package directory, and verify that your package can be loaded successfully in a Julia REPL.","category":"section"},{"location":"diagnostic/#inference-diagnostic","page":"Diagnostic","title":"Inference diagnostic (inference/*)","text":"Inference diagnostic uses JET.jl to perform type-aware analysis and detect potential errors through static analysis. These diagnostics are also reported by JETLS's full analysis feature (see Top-level diagnostic for details on when analysis runs).","category":"section"},{"location":"diagnostic/#diagnostic/inference/undef-global-var","page":"Diagnostic","title":"Undefined global variable (inference/undef-global-var)","text":"Default severity: Warning\n\nReferences to undefined global variables.\n\nExample:\n\nfunction undef_global_var()\n    return undefined_global  # `undefined_global` is not defined (JETLS inference/undef-global-var)\nend","category":"section"},{"location":"diagnostic/#diagnostic/inference/undef-local-var","page":"Diagnostic","title":"Undefined local variable (inference/undef-local-var)","text":"Default severity: Information or Warning\n\nReferences to undefined local variables. The severity depends on whether the variable is definitely undefined (Warning) or only possibly undefined (Information).\n\nExample:\n\nfunction undef_local_var()\n    if rand() > 0.5\n        x = 1\n    end\n    return x  # local variable `x` may be undefined (JETLS inference/undef-local-var)\nend","category":"section"},{"location":"diagnostic/#diagnostic/testrunner","page":"Diagnostic","title":"TestRunner diagnostic (testrunner/*)","text":"","category":"section"},{"location":"diagnostic/#diagnostic/testrunner/test-failure","page":"Diagnostic","title":"Test failure (testrunner/test-failure)","text":"Default severity: Error\n\nTest failures reported by TestRunner integration that happened during running individual @testset blocks or @test cases.","category":"section"},{"location":"diagnostic/#configuring-diagnostic","page":"Diagnostic","title":"Configuring diagnostic","text":"You can configure which diagnostics are shown and at what severity level under the [diagnostic] section. This allows you to customize JETLS's behavior to match your project's coding standards and preferences.\n\nnothing # This is an internal comment for this documenation: # hide\nnothing # Use H5 for subsections in this section so that the `@contents` block above works as intended. # hide","category":"section"},{"location":"diagnostic/#Common-use-cases","page":"Diagnostic","title":"Common use cases","text":"Suppress specific macro expansion errors:\n\n[[diagnostic.patterns]]\npattern = \"Macro name `MyPkg.@mymacro` not found\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\nApply different settings for test files:\n\n# Downgrade unused arguments to hints in test files\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\npath = \"test/**/*.jl\"\n\n# Disable all diagnostics for generated code\n[[diagnostic.patterns]]\npattern = \".*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\npath = \"gen/**/*.jl\"\n\nDisable unused variable warnings during prototyping:\n\n[[diagnostic.patterns]]\npattern = \"lowering/(unused-argument|unused-local)\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\nMake inference diagnostic less intrusive:\n\n[[diagnostic.patterns]]\npattern = \"inference/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"hint\"\n\nFor complete configuration options, severity values, pattern matching syntax, and more examples, see the [diagnostic] configuration section in the JETLS configuration page.","category":"section"},{"location":"configuration/#JETLS-configuration","page":"Configuration","title":"JETLS configuration","text":"JETLS supports various configuration options. This documentation uses TOML format to describe the configuration schema.","category":"section"},{"location":"configuration/#config/schema","page":"Configuration","title":"Configuration schema","text":"[full_analysis]\ndebounce = 1.0             # number (seconds), default: 1.0\n\nformatter = \"Runic\"        # String preset: \"Runic\" (default) or \"JuliaFormatter\"\n\n[formatter.custom]         # Or custom formatter configuration\nexecutable = \"\"            # string (path), optional\nexecutable_range = \"\"      # string (path), optional\n\n[diagnostic]\nenabled = true             # boolean, default: true\n\n[[diagnostic.patterns]]\npattern = \"\"               # string, required\nmatch_by = \"\"              # string, required, \"code\" or \"message\"\nmatch_type = \"\"            # string, required, \"literal\" or \"regex\"\nseverity = \"\"              # string or number, required, \"error\"/\"warning\"/\"warn\"/\"information\"/\"info\"/\"hint\"/\"off\" or 0/1/2/3/4\npath = \"\"                  # string (optional), glob pattern for file paths\n\n[testrunner]\nexecutable = \"testrunner\"  # string, default: \"testrunner\" (or \"testrunner.bat\" on Windows)","category":"section"},{"location":"configuration/#config/reference","page":"Configuration","title":"Configuration reference","text":"[full_analysis]\n[full_analysis] debounce\nformatter\n[diagnostic]\n[diagnostic] enabled\n[[diagnostic.patterns]]\n[testrunner]\n[testrunner] executable","category":"section"},{"location":"configuration/#config/full_analysis","page":"Configuration","title":"[full_analysis]","text":"","category":"section"},{"location":"configuration/#config/full_analysis-debounce","page":"Configuration","title":"[full_analysis] debounce","text":"Type: number (seconds)\nDefault: 1.0\n\nDebounce time in seconds before triggering full analysis after a file save. JETLS performs type-aware analysis using JET.jl to detect potential errors. The debounce prevents excessive analysis when you save files frequently. Higher values reduce analysis frequency (saving CPU) but may delay diagnostic updates.\n\n[full_analysis]\ndebounce = 2.0  # Wait 2 seconds after save before analyzing","category":"section"},{"location":"configuration/#config/formatter","page":"Configuration","title":"formatter","text":"Type: string or table\nDefault: \"Runic\"\n\nFormatter configuration. Can be a preset name or a custom formatter object.\n\nPreset options:\n\n\"Runic\" (default): Uses Runic.jl (\"runic\" or \"runic.bat\" on Windows)\n\"JuliaFormatter\": Uses JuliaFormatter.jl (\"jlfmt\" or \"jlfmt.bat\" on Windows)\n\nCustom formatter configuration:\n\nformatter.custom.executable (string, optional): Path to custom formatter executable for document formatting. The formatter should read Julia code from stdin and output formatted code to stdout.\nformatter.custom.executable_range (string, optional): Path to custom formatter executable for range formatting. Should accept --lines=START:END argument.\n\nExamples:\n\n# Use JuliaFormatter preset\nformatter = \"JuliaFormatter\"\n\n# Or use custom formatter (both fields optional)\n[formatter.custom]\nexecutable = \"/path/to/custom-formatter\"\nexecutable_range = \"/path/to/custom-range-formatter\"\n\nSee Formatting for detailed configuration instructions and setup requirements.","category":"section"},{"location":"configuration/#config/diagnostic","page":"Configuration","title":"[diagnostic]","text":"Configure how JETLS reports diagnostic messages (errors, warnings, infos, hints) in your editor. JETLS uses hierarchical diagnostic codes in the format \"category/kind\" (following the LSP specification) to allow fine-grained control over which diagnostics to show and at what severity level.\n\nSee the Diagnostic section for complete diagnostic reference including all available codes, their meanings, and examples.","category":"section"},{"location":"configuration/#config/diagnostic-enabled","page":"Configuration","title":"[diagnostic] enabled","text":"Type: boolean\nDefault: true\n\nEnable or disable all JETLS diagnostics. When set to false, no diagnostic messages will be shown.\n\n[diagnostic]\nenabled = false  # Disable all diagnostics","category":"section"},{"location":"configuration/#config/diagnostic-patterns","page":"Configuration","title":"[[diagnostic.patterns]]","text":"Fine-grained control over diagnostics through pattern matching against either diagnostic codes or messages.\n\nSee the diagnostic reference section for a complete list of all available diagnostic codes, their default severity levels, and detailed explanations with examples.","category":"section"},{"location":"configuration/#Configuration-syntax","page":"Configuration","title":"Configuration syntax","text":"Each pattern is defined as a table array entry with the following fields:\n\n[[diagnostic.patterns]]\npattern = \"pattern-value\"  # string: the pattern to match\nmatch_by = \"code\"          # string: \"code\" or \"message\"\nmatch_type = \"literal\"     # string: \"literal\" or \"regex\"\nseverity = \"hint\"          # string or number: severity level\npath = \"src/**/*.jl\"       # string (optional): restrict to specific files\n\npattern (Type: string): The pattern to match. For code matching, use diagnostic codes like \"lowering/unused-argument\". For message matching, use text patterns like \"Macro name .* not found\".\nmatch_by (Type: string): What to match against\n\"code\": Match against diagnostic code (e.g., \"lowering/unused-argument\")\n\"message\": Match against diagnostic message text\nmatch_type (Type: string): How to interpret the pattern\n\"literal\": Exact string match\n\"regex\": Regular expression match\nseverity (Type: string or number): Severity level to apply\npath (Type: string, optional): Glob pattern to restrict this configuration to specific files. Patterns are matched against file paths relative to the workspace root. Supports globstar (**) for matching directories recursively. If omitted, the pattern applies to all files.","category":"section"},{"location":"configuration/#Severity-values","page":"Configuration","title":"Severity values","text":"Severity level to apply. Can be specified using either string or number values:\n\n\"error\" or 1: Critical issues that prevent code from working correctly\n\"warning\" or \"warn\" or 2: Potential problems that should be reviewed\n\"information\" or \"info\" or 3: Informational messages about code that may benefit from attention\n\"hint\" or 4: Suggestions for improvements or best practices\n\"off\" or 0: Disable the diagnostic\n\nString values are case-insensitive. The numeric values correspond to the LSP specification, while \"off\"/0 is a JETLS-specific extension for disabling diagnostics.","category":"section"},{"location":"configuration/#Pattern-matching-priority","page":"Configuration","title":"Pattern matching priority","text":"When multiple patterns match the same diagnostic, more specific patterns take precedence. The priority order (highest to lowest) is:\n\nmessage literal match\nmessage regex match\ncode literal match\ncode regex match\n\nThis priority strategy allows message-based patterns to override code-based patterns, enabling fine-grained control for specific diagnostic instances.\n\nExample showing priority:\n\n# Lower priority: matches all lowering diagnostics\n[[diagnostic.patterns]]\npattern = \"lowering/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"error\"\n\n# Higher priority: matches specific message\n[[diagnostic.patterns]]\npattern = \"Unused argument `x`\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n# Highest priority among code patterns: exact code match\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\n\nnote: Note\nWhen diagnostic.enabled is false, all diagnostics are disabled regardless of pattern settings.","category":"section"},{"location":"configuration/#[diagnostic]-configuration-examples","page":"Configuration","title":"[diagnostic] configuration examples","text":"[diagnostic]\nenabled = true\n\n# Pattern matching against diagnostic code\n[[diagnostic.patterns]]\npattern = \"lowering/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"warning\"\n\n# Disable inference diagnostic entirely\n[[diagnostic.patterns]]\npattern = \"inference/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\n# Show unused arguments as hints (overrides category setting)\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\n\n# Completely disable unused local variable diagnostics using integer value\n[[diagnostic.patterns]]\npattern = \"lowering/unused-local\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = 0\n\n# Pattern matching against diagnostic message\n[[diagnostic.patterns]]\npattern = \"Macro name `@interface` not found\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n# Suppress all macro not found errors using regex\n[[diagnostic.patterns]]\npattern = \"Macro name `.*` not found\"\nmatch_by = \"message\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\n# File path-based filtering: downgrade unused arguments in test files\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\npath = \"test/**/*.jl\"\n\n# Disable all diagnostics for generated files\n[[diagnostic.patterns]]\npattern = \".*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\npath = \"gen/**/*.jl\"\n\nSee the configuring diagnostics section for additional examples and common use cases.","category":"section"},{"location":"configuration/#config/testrunner","page":"Configuration","title":"[testrunner]","text":"","category":"section"},{"location":"configuration/#config/testrunner-executable","page":"Configuration","title":"[testrunner] executable","text":"Type: string\nDefault: \"testrunner\" or \"testrunner.bat\" on Windows\n\nPath to the TestRunner.jl executable for running individual @testset blocks and @test cases.\n\n[testrunner]\nexecutable = \"/path/to/custom/testrunner\"\n\nSee TestRunner integration for setup instructions.","category":"section"},{"location":"configuration/#How-to-configure-JETLS","page":"Configuration","title":"How to configure JETLS","text":"","category":"section"},{"location":"configuration/#config/file-based-config","page":"Configuration","title":"Method 1: File-based configuration","text":"Create a .JETLSConfig.toml file in your project root. This configuration method works client-agnostically, thus allows projects to commit configuration to VCS without writing JETLS configurations in various formats that each client can understand.\n\nExample .JETLSConfig.toml:\n\n[full_analysis]\ndebounce = 2.0\n\n# Use JuliaFormatter instead of Runic\nformatter = \"JuliaFormatter\"\n\n# Suppress unused argument warnings\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n[testrunner]\nexecutable = \"/path/to/custom/testrunner\"","category":"section"},{"location":"configuration/#config/lsp-config","page":"Configuration","title":"Method 2: Editor configuration via LSP","text":"If your client supports workspace/configuration, you can configure JETLS in a client-specific manner. As examples, we show the configuration methods for the VSCode extension jetls-client, and the Zed extension aviatesk/zed-julia#avi/JETLS.","category":"section"},{"location":"configuration/#config/lsp-config/vscode","page":"Configuration","title":"VSCode (jetls-client extension)","text":"Configure JETLS in VSCode's settings.json file with jetls-client.settings section:\n\nExample .vscode/settings.json:\n\n{\n  \"jetls-client.settings\": {\n    \"full_analysis\": {\n      \"debounce\": 2.0\n    },\n    // Use JuliaFormatter instead of Runic\n    \"formatter\": \"JuliaFormatter\",\n    \"diagnostic\": {\n      \"patterns\": [\n        // Suppress toplevel/inference warnings in test folder\n        {\n          \"pattern\": \"(toplevel|inference)/.*\",\n          \"match_by\": \"code\",\n          \"match_type\": \"regex\",\n          \"severity\": \"off\",\n          \"path\": \"test/**/*.jl\"\n        }\n      ]\n    },\n    \"testrunner\": {\n      \"executable\": \"/path/to/custom/testrunner\"\n    }\n  }\n}\n\nSee package.json for the complete list of available VSCode settings and their descriptions.","category":"section"},{"location":"configuration/#config/lsp-config/zed","page":"Configuration","title":"Zed (aviatesk/zed-julia#avi/JETLS extension)","text":"Configure JETLS in Zed's settings.json file with the lsp.JETLS.settings section:\n\nExample .zed/settings.json:\n\n{\n  \"lsp\": {\n    \"JETLS\": {\n      \"settings\": {\n        \"full_analysis\": {\n          \"debounce\": 2.0\n        },\n        // Use JuliaFormatter instead of Runic\n        \"formatter\": \"JuliaFormatter\",\n        \"diagnostic\": {\n          \"patterns\": [\n            // Suppress toplevel/inference warnings in test folder\n            {\n              \"pattern\": \"(toplevel|inference)/.*\",\n              \"match_by\": \"code\",\n              \"match_type\": \"regex\",\n              \"severity\": \"off\",\n              \"path\": \"test/**/*.jl\"\n            }\n          ]\n        },\n        \"testrunner\": {\n          \"executable\": \"/path/to/custom/testrunner\"\n        }\n      }\n    }\n  }\n}","category":"section"},{"location":"configuration/#Configuration-priority","page":"Configuration","title":"Configuration priority","text":"When multiple configuration sources are present, they are merged in priority order (highest first):\n\nFile-based configuration (.JETLSConfig.toml)\nEditor configuration via LSP (workspace/configuration)\nBuilt-in defaults\n\nFile-based configuration (.JETLSConfig.toml) takes precedence as it provides a client-agnostic way to configure JETLS that works consistently across all editors.","category":"section"},{"location":"#JETLS.jl-documentation","page":"Index","title":"JETLS.jl documentation","text":"The goal of this project is to develop a new language server for Julia, currently called \"JETLS\". JETLS aims to enhance developer productivity by providing advanced static analysis and seamless integration with the Julia runtime. By leveraging tooling technologies like JET.jl, JuliaSyntax.jl and JuliaLowering.jl, JETLS aims to offer enhanced language features such as type-sensitive diagnostic, macro-aware go-to definition and such.","category":"section"},{"location":"#Server-installation","page":"Index","title":"Server installation","text":"Editor clients for JETLS generally do not bundle the JETLS server itself. You need to install the jetls executable separately before using any editor integration.","category":"section"},{"location":"#Prerequisites","page":"Index","title":"Prerequisites","text":"JETLS requires Julia v\"1.12\" or higher, so ensure that the Julia version of the julia command you use is v1.12 or higher.","category":"section"},{"location":"#Installing-the-jetls-executable","page":"Index","title":"Installing the jetls executable","text":"All editor integrations require the jetls executable app, which is the main entry point for running JETLS.\n\nInstall it with:\n\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\n\nThis will install the jetls executable (jetls.exe on Windows) to ~/.julia/bin/. Make sure ~/.julia/bin is available on the PATH environment so the executable is accessible.\n\nYou can verify the installation by running:\n\njetls --help\n\nIf this displays the help message, the installation was successful and ~/.julia/bin is properly added to your PATH.\n\ninfo: Updating JETLS\nTo update JETLS to the latest version:julia -e 'using Pkg; Pkg.Apps.update(\"JETLS\")'When installed with rev=\"release\" (as shown above), Pkg.Apps.update(\"JETLS\") will fetch the most recent version since the release branch always points to the latest release.To pin a specific version instead, use rev=\"releases/YYYY-MM-DD\":julia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"releases/2025-11-25\")'Note that pinned versions will not be updated by Pkg.Apps.update(\"JETLS\").","category":"section"},{"location":"#Editor-setup","page":"Index","title":"Editor setup","text":"After installing the jetls executable, set up your editor to use it.","category":"section"},{"location":"#VSCode","page":"Index","title":"VSCode","text":"jetls-client is a VSCode client extension for JETLS.[1]\n\n[1]: Requires VSCode v1.96.0 or higher.\n\nInstall the jetls-client extension from the VSCode Extensions marketplace (search for \"JETLS Client\" from the extensions view), then open any Julia file. The extension will automatically use the jetls executable from your PATH.\n\nFor advanced launching configurations and JETLS behavior settings, see the jetls-client README.","category":"section"},{"location":"#Emacs","page":"Index","title":"Emacs","text":"Minimal Emacs (eglot client) setup:\n\n(add-to-list 'eglot-server-programs\n              '(((julia-mode :language-id \"julia\")\n                (julia-ts-mode :language-id \"julia\"))\n                \"jetls\"\n                \"--threads=auto\"\n                \"--\"\n                \"--socket\"\n                :autoport))","category":"section"},{"location":"#Neovim","page":"Index","title":"Neovim","text":"Minimal Neovim setup (requires Neovim v0.11):\n\nvim.lsp.config(\"jetls\", {\n    cmd = {\n        \"jetls\",\n        \"--threads=auto\",\n        \"--\",\n    },\n    filetypes = {\"julia\"},\n})\nvim.lsp.enable(\"jetls\")","category":"section"},{"location":"#Zed","page":"Index","title":"Zed","text":"Zed extension for Julia/JETLS is available: See aviatesk/zed-julia#avi/JETLS for the detailed installation steps.","category":"section"},{"location":"#Helix","page":"Index","title":"Helix","text":"Minimal Helix setup:\n\nlanguages.toml\n\n[[language]]\nname = \"julia\"\nlanguage-servers = [ \"jetls\" ]\n\n[language-server]\njetls = { command = \"jetls\", args = [\"--threads=auto\", \"--\"] }","category":"section"},{"location":"#Quick-links","page":"Index","title":"Quick links","text":"","category":"section"},{"location":"testrunner/#TestRunner-integration","page":"TestRunner integration","title":"TestRunner integration","text":"JETLS integrates with TestRunner.jl to provide an enhanced testing experience directly within your editor. This feature allows you to run individual @testset blocks directly from your development environment.","category":"section"},{"location":"testrunner/#Prerequisites","page":"TestRunner integration","title":"Prerequisites","text":"To use this feature, you need to install the testrunner executable:\n\njulia -e 'using Pkg; Pkg.Apps.add(url=\"https://github.com/aviatesk/TestRunner.jl\")'\n\nNote that you need to manually make ~/.julia/bin available on the PATH environment for the testrunner executable to be accessible. See https://pkgdocs.julialang.org/dev/apps/ for the details.","category":"section"},{"location":"testrunner/#Features","page":"TestRunner integration","title":"Features","text":"","category":"section"},{"location":"testrunner/#Code-lens","page":"TestRunner integration","title":"Code lens","text":"When you open a Julia file containing @testset blocks, JETLS displays interactive code lenses above each @testset:\n\n▶ Run \"testset_name\": Run the testset for the first time<img class=\"display-light-only\" src=\"../assets/testrunner-code-lens.png\" alt=\"TestRunner Code Lens\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-lens-dark.png\" alt=\"TestRunner Code Lens\"/>\n\nAfter running tests, the code lens is refreshed as follows:\n\n▶ Rerun \"testset_name\" [summary]: Re-run a testset that has previous results\n☰ Open logs: View the detailed test output in a new editor tab\n✓ Clear result: Remove the test results and inline diagnostics<img class=\"display-light-only\" src=\"../assets/testrunner-code-lens-refreshed.png\" alt=\"TestRunner Code Lens with Results\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-lens-refreshed-dark.png\" alt=\"TestRunner Code Lens with Results\"/>","category":"section"},{"location":"testrunner/#Code-actions","page":"TestRunner integration","title":"Code actions","text":"You can trigger test runs via \"code actions\" that are explicitly requested by the user:\n\nInside a @testset block: Run the entire testset<img class=\"display-light-only\" src=\"../assets/testrunner-code-actions.png\" alt=\"TestRunner Code Actions\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-actions-dark.png\" alt=\"TestRunner Code Actions\"/>\n\nOn an individual @test macro: Run just that specific test case<img class=\"display-light-only\" src=\"../assets/testrunner-code-actions-test-case.png\" alt=\"TestRunner Code Actions @test case\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-actions-test-case-dark.png\" alt=\"TestRunner Code Actions @test case\"/>\n\nNote that when running individual @test cases, the error results are displayed as temporary diagnostics for 10 seconds. Click ☰ Open logs button in the pop up message to view detailed error messages that persist.","category":"section"},{"location":"testrunner/#Test-diagnostics","page":"TestRunner integration","title":"Test diagnostics","text":"Failed tests are displayed as diagnostics (red squiggly lines) at the exact lines where the failures occurred, making it easy to identify and fix issues:\n\n<img class=\"display-light-only\" src=\"../assets/testrunner-diagnostics.png\" alt=\"TestRunner Diagnostics\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-diagnostics-dark.png\" alt=\"TestRunner Diagnostics\"/>","category":"section"},{"location":"testrunner/#Progress-notifications","page":"TestRunner integration","title":"Progress notifications","text":"For clients that support work done progress, JETLS shows progress notifications while tests are running, keeping you informed about long-running test suites.","category":"section"},{"location":"testrunner/#Supported-patterns","page":"TestRunner integration","title":"Supported patterns","text":"The TestRunner integration supports:\n\nNamed @testset blocks (via code lens or code actions):\nusing Test\n\n# supported: named `@testset`\n@testset \"foo\" begin\n  @test sin(0) == 0\n  @test sin(Inf) == 0\n  @test_throws ErrorException sin(Inf) == 0\n  @test cos(π) == -1\n\n    # supported: nested named `@testset`\n    @testset \"bar\" begin\n      @test sin(π) == 0\n      @test sin(0) == 1\n      @test cos(Inf) == -1\n    end\nend\n\n# unsupported: `@testset` inside function definition\nfunction test_func1()\n  @testset \"inside function\" begin\n    @test true\n  end\nend\n\n# supported: this pattern is fine\nfunction test_func2()\n  @testset \"inside function\" begin\n    @test true\n  end\nend\n@testset \"test_func2\" test_func2()\nIndividual @test macros (via code actions only):\n# Run individual tests directly\n@test 1 + 1 == 2\n@test sqrt(4) ≈ 2.0\n\n# Also works inside testsets\n@testset \"math tests\" begin\n  @test sin(0) == 0  # Can run just this test\n  @test cos(π) == -1  # Or just this one\nend\n\n# Multi-line `@test` expressions are just fine\n@test begin\n  x = complex_calculation()\n  validate(x)\nend\n\n# Other Test.jl macros are supported too\n@test_throws DomainErrors sin(Inf)\n\nSee the TestRunner.jl README for more details.","category":"section"},{"location":"testrunner/#Troubleshooting","page":"TestRunner integration","title":"Troubleshooting","text":"If you see an error about testrunner not being found:\n\nEnsure you've installed TestRunner.jl as described above\nCheck that testrunner is in your system PATH by running which testrunner: otherwise you may need to add ~/.julia/bin to PATH\nRestart your editor to ensure it picks up the updated PATH\n\nTest execution requires that your file is saved and matches the on-disk version. If you see a message asking you to save the file first, make sure to save your changes before running tests.","category":"section"}]
}

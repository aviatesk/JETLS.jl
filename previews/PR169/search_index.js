var documenterSearchIndex = {"docs":
[{"location":"testrunner/#testrunner","page":"TestRunner integration","title":"TestRunner integration","text":"JETLS integrates with TestRunner.jl to provide an enhanced testing experience directly within your editor. This feature allows you to run individual @testset blocks directly from your development environment.","category":"section"},{"location":"testrunner/#testrunner/prerequisites","page":"TestRunner integration","title":"Prerequisites","text":"To use this feature, you need to install the testrunner executable:\n\njulia -e 'using Pkg; Pkg.Apps.add(url=\"https://github.com/aviatesk/TestRunner.jl#release\")'\n\nNote that you need to manually make ~/.julia/bin available on the PATH environment for the testrunner executable to be accessible. See https://pkgdocs.julialang.org/dev/apps/ for the details.","category":"section"},{"location":"testrunner/#testrunner/features","page":"TestRunner integration","title":"Features","text":"","category":"section"},{"location":"testrunner/#testrunner/features/code-lens","page":"TestRunner integration","title":"Code lens","text":"When you open a Julia file containing @testset blocks, JETLS displays interactive code lenses above each @testset:\n\n▶ Run \"testset_name\": Run the testset for the first time<img class=\"display-light-only\" src=\"../assets/testrunner-code-lens.png\" alt=\"TestRunner Code Lens\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-lens-dark.png\" alt=\"TestRunner Code Lens\"/>\n\nAfter running tests, the code lens is refreshed as follows:\n\n▶ Rerun \"testset_name\" [summary]: Re-run a testset that has previous results\n☰ Open logs: View the detailed test output in a new editor tab\n✓ Clear result: Remove the test results and inline diagnostics<img class=\"display-light-only\" src=\"../assets/testrunner-code-lens-refreshed.png\" alt=\"TestRunner Code Lens with Results\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-lens-refreshed-dark.png\" alt=\"TestRunner Code Lens with Results\"/>","category":"section"},{"location":"testrunner/#testrunner/features/code-actions","page":"TestRunner integration","title":"Code actions","text":"You can trigger test runs via \"code actions\" that are explicitly requested by the user:\n\nInside a @testset block: Run the entire testset<img class=\"display-light-only\" src=\"../assets/testrunner-code-actions.png\" alt=\"TestRunner Code Actions\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-actions-dark.png\" alt=\"TestRunner Code Actions\"/>\n\nOn an individual @test macro: Run just that specific test case<img class=\"display-light-only\" src=\"../assets/testrunner-code-actions-test-case.png\" alt=\"TestRunner Code Actions @test case\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-code-actions-test-case-dark.png\" alt=\"TestRunner Code Actions @test case\"/>\n\nNote that when running individual @test cases, the error results are displayed as temporary diagnostics for 10 seconds. Click ☰ Open logs button in the pop up message to view detailed error messages that persist.","category":"section"},{"location":"testrunner/#testrunner/features/test-diagnostics","page":"TestRunner integration","title":"Test diagnostics","text":"Failed tests are displayed as diagnostics (red squiggly lines) at the exact lines where the failures occurred, making it easy to identify and fix issues:\n\n<img class=\"display-light-only\" src=\"../assets/testrunner-diagnostics.png\" alt=\"TestRunner Diagnostics\"/>\n<img class=\"display-dark-only\" src=\"../assets/testrunner-diagnostics-dark.png\" alt=\"TestRunner Diagnostics\"/>","category":"section"},{"location":"testrunner/#testrunner/features/progress-notifications","page":"TestRunner integration","title":"Progress notifications","text":"For clients that support work done progress, JETLS shows progress notifications while tests are running, keeping you informed about long-running test suites.","category":"section"},{"location":"testrunner/#testrunner/supported-patterns","page":"TestRunner integration","title":"Supported patterns","text":"The TestRunner integration supports:\n\nNamed @testset blocks (via code lens or code actions):\nusing Test\n\n# supported: named `@testset`\n@testset \"foo\" begin\n  @test sin(0) == 0\n  @test sin(Inf) == 0\n  @test_throws ErrorException sin(Inf) == 0\n  @test cos(π) == -1\n\n    # supported: nested named `@testset`\n    @testset \"bar\" begin\n      @test sin(π) == 0\n      @test sin(0) == 1\n      @test cos(Inf) == -1\n    end\nend\n\n# unsupported: `@testset` inside function definition\nfunction test_func1()\n  @testset \"inside function\" begin\n    @test true\n  end\nend\n\n# supported: this pattern is fine\nfunction test_func2()\n  @testset \"inside function\" begin\n    @test true\n  end\nend\n@testset \"test_func2\" test_func2()\nIndividual @test macros (via code actions only):\n# Run individual tests directly\n@test 1 + 1 == 2\n@test sqrt(4) ≈ 2.0\n\n# Also works inside testsets\n@testset \"math tests\" begin\n  @test sin(0) == 0  # Can run just this test\n  @test cos(π) == -1  # Or just this one\nend\n\n# Multi-line `@test` expressions are just fine\n@test begin\n  x = complex_calculation()\n  validate(x)\nend\n\n# Other Test.jl macros are supported too\n@test_throws DomainErrors sin(Inf)\n\nSee the TestRunner.jl README for more details.","category":"section"},{"location":"testrunner/#testrunner/troubleshooting","page":"TestRunner integration","title":"Troubleshooting","text":"If you see an error about testrunner not being found:\n\nEnsure you've installed TestRunner.jl as described above\nCheck that testrunner is in your system PATH by running which testrunner: otherwise you may need to add ~/.julia/bin to PATH\nRestart your editor to ensure it picks up the updated PATH\n\nTest execution requires that your file is saved and matches the on-disk version. If you see a message asking you to save the file first, make sure to save your changes before running tests.","category":"section"},{"location":"CHANGELOG/#CHANGELOG","page":"CHANGELOG","title":"CHANGELOG","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog.\n\nnote: Note\nJETLS uses date-based versioning (YYYY-MM-DD) rather than semantic versioning, as it is not registered in General due to environment isolation requirements.Each dated section below corresponds to a release that can be installed via Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"YYYY-MM-DD\")To install the latest version regardless of date, re-run the installation command:julia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'","category":"section"},{"location":"CHANGELOG/#Unreleased","page":"CHANGELOG","title":"Unreleased","text":"Commit: HEAD\nDiff: 150f880...HEAD","category":"section"},{"location":"CHANGELOG/#Announcement","page":"CHANGELOG","title":"Announcement","text":"warning: Warning\nJETLS currently has a known memory leak issue where memory usage grows with each re-analysis (aviatesk/JETLS.jl#357). As a temporary workaround, you can disable full-analysis for specific files using the analysis_overrides initialization option:// VSCode settings.json example\n{\n  \"jetls-client.initializationOptions\": {\n    \"analysis_overrides\": [\n      { \"path\": \"src/**/*.jl\" },\n      { \"path\": \"test/**/*.jl\" }\n    ]\n  }\n}This disables analysis for matched files. Basic features like completion still might work, but most LSP features will be unfunctional. Note that analysis_overrides is provided as a temporary workaround and may be removed or changed at any time. A proper fix is being worked on.","category":"section"},{"location":"CHANGELOG/#2026-02-11","page":"CHANGELOG","title":"2026-02-11","text":"Commit: 150f880\nDiff: 9c00dfe...150f880\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-02-11\")'","category":"section"},{"location":"CHANGELOG/#Added","page":"CHANGELOG","title":"Added","text":"Added jetls check command for running JETLS diagnostics from the command line. This enables CI integration and command-line workflows without requiring an editor. Features include --exit-severity for controlling exit codes, --show-severity for filtering output, --context-lines for output formatting, and --root for configuration lookup. The CLI now uses a subcommand structure: jetls serve starts the language server (default), while jetls check runs diagnostics.\nAdded lowering/unused-import diagnostic that reports explicitly imported names that are never used within the same module space. The \"Remove unused import\" code action removes the unused name from the import statement.\nAdded reference count code lens for top-level symbols (functions, structs, constants, abstract types, primitive types, modules). When enabled, a code lens showing \"N references\" appears above each symbol definition. Clicking it opens the references panel. This feature is opt-in and can be enabled via code_lens.references configuration.\nAdded code_lens.testrunner configuration option to enable or disable TestRunner code lenses. Some editors (e.g., Zed) display code lenses as code actions, causing duplication. The aviatesk/zed-julia extension automatically defaults this to false.\nAdded document symbol support for if and @static if blocks. These blocks now appear in the document outline as SymbolKind.Namespace symbols, with all definitions from if/elseif/else branches flattened as children.\nAdded document symbol support for @testset and @test macros. @testset blocks appear in the document outline with the test name, and @test expressions appear as children showing the test expression.\nAdded inlay hints for block end keywords. For long blocks (module, function, macro, struct, if/@static if, let, for, while, @testset), an inlay hint is displayed at the end keyword showing what construct is ending, such as module Foo or function bar. The minimum block length can be configured via inlay_hint.block_end_min_lines (default: 25 lines).","category":"section"},{"location":"CHANGELOG/#Deprecated","page":"CHANGELOG","title":"Deprecated","text":"Running jetls without a subcommand (e.g., jetls --stdio) is deprecated. Use jetls serve instead. This may be removed in a future release.","category":"section"},{"location":"CHANGELOG/#Changed","page":"CHANGELOG","title":"Changed","text":"Namespace symbols (if/let/for/while/@static if blocks) are now excluded from workspace symbol search. These symbols exist only to provide hierarchical structure in the document outline, not to represent actual definitions.\ntextDocument/diagnostic now supports cancellation, avoiding to compute staled diagnostics (aviatesk/JETLS.jl#524)\nUpdated JuliaSyntax.jl and JuliaLowering.jl dependency versions to latest, fixing the root causes of aviatesk/JETLS.jl#492, and aviatesk/JETLS.jl#508.","category":"section"},{"location":"CHANGELOG/#Fixed","page":"CHANGELOG","title":"Fixed","text":"Lowering diagnostics no longer report issues in macro-generated code that users cannot control. User-written identifiers processed by new-style macros are still reported, but old-style macros are not yet supported due to JuliaLowering limitations.\nFixed false positive lowering/unused-argument and lowering/unused-local diagnostics that could appear before full-analysis completes when macros cannot be expanded. Fixed aviatesk/JETLS.jl#522.\nFixed diagnostic configuration pattern merging to use composite keys. Previously, patterns with the same pattern value but different path would overwrite each other. Now patterns are identified by (match_by, match_type, path, pattern), allowing multiple rules for the same pattern with different paths.\nFixed potential segfault on server exit by implementing graceful shutdown of worker tasks. All Threads.@spawned tasks are now properly terminated before the server exits. (xref: https://github.com/JuliaLang/julia/issues/32983, aviatesk/JETLS.jl#523)\nFixed thread-safety issue with cached syntax trees. Multiple threads accessing the same cached tree during lowering could cause data races and segfaults. Cached trees are now copied before use. (aviatesk/JETLS.jl#525)\nFixed cache not being generated in some cases in the experimental incremental analysis mode. The cache is now always created when CodeInstance is available, ensuring cache reuse works reliably.\nFixed auto-instantiate creating unwanted versioned manifest files (e.g., Manifest-v1.12.toml) via touch. A manifest is now only created when Pkg.instantiate() needs one. (aviatesk/JETLS.jl#511,  aviatesk/JETLS.jl#536;  thanks visr)","category":"section"},{"location":"CHANGELOG/#2026-01-23","page":"CHANGELOG","title":"2026-01-23","text":"Commit: 9c00dfe\nDiff: c8e2012...9c00dfe\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-23\")'","category":"section"},{"location":"CHANGELOG/#Added-2","page":"CHANGELOG","title":"Added","text":"Added workspace/diagnostic support to provide JETLS/live diagnostics (syntax errors and lowering-based analysis) for unopened files in the workspace.\nAdded diagnostic.all_files configuration option to control whether diagnostics are reported for unopened files. Disabling this can be useful to reduce noise when there are many warnings across the workspace.\nAdded lowering/unsorted-import-names diagnostic that reports when names in import, using, export, or public statements are not sorted alphabetically. The \"Sort import names\" code action is available to automatically fix the ordering.\ntextDocument/documentHighlight now supports macro bindings. Highlighting a macro name (either in the definition or at a call site) shows all occurrences of that macro within the document.\ntextDocument/references now supports macro bindings. Finding references on a macro name (either in the definition or at a call site) shows all occurrences of that macro across the package.","category":"section"},{"location":"CHANGELOG/#Changed-2","page":"CHANGELOG","title":"Changed","text":"Updated TestRunner.jl installation instructions to use the #release branch for vendored dependencies. TestRunner.jl should now be installed via\njulia -e 'using Pkg; Pkg.Apps.add(url=\"https://github.com/aviatesk/TestRunner.jl#release\")'\n(aviatesk/TestRunner.jl#14).\nReplaced inference/undef-local-var with new lowering/undef-local-var diagnostic. The new diagnostic uses CFG-aware analysis on lowered code, providing faster feedback via textDocument/diagnostic without waiting for full analysis, and offers precise source location information. See the diagnostic reference for details and workarounds.\ntextDocument/documentSymbol now uses SymbolKind.Object for function arguments instead of SymbolKind.Variable. This visually distinguishes arguments from local variables in the document outline. Since LSP does not provide a dedicated SymbolKind.Argument, Object is used as a workaround.\nworkspace/symbol now shows the parent function signature or struct name as the container name for arguments or fields respectively, making it clearer which function or struct they belong to during workspace symbol search.\nDiagnostic source field now uses distinct values to indicate which channel delivers the diagnostic: JETLS/live for on-change diagnostics, JETLS/save for on-save full analysis, and JETLS/extra for external sources like the TestRunner.jl integration. This helps users understand when diagnostics update and enables filtering by source in editors that support it. See the Sources documentation for details.\nYet more improved performance of workspace/symbol, textDocument/references,\n\ntextDocument/rename, and textDocument/definition by avoiding re-parsing of   already analyzed files not opened in the editor.\n\nworkspace/configuration requests now expect settings to be found under the top-level \"jetls\" key, such that a request with section = \"jetls\" produces the full configuration. This is to ensure compatibility with generic clients, e.g., the neovim client, which may not conform to JETLS's previous expectations about how requests with no section are handled. (aviatesk/JETLS.jl#483; thanks danielwe)\nUpdated JuliaSyntax.jl and JuliaLowering.jl dependency versions to latest.","category":"section"},{"location":"CHANGELOG/#Fixed-2","page":"CHANGELOG","title":"Fixed","text":"Fixed LSP features not working inside @main functions.\nFixed false positive lowering/captured-boxed-variable diagnostic when a struct's inner constructor defines a local variable with the same name as a type parameter (e.g., struct Foo{T} with T = typeof(x) in the constructor). (aviatesk/JETLS.jl#508)\nFixed severe performance issue when analyzing test files containing many @test and @testset macros. The underlying JuliaLowering issue caused macro expansion to be 40-300x slower for test files compared to regular source files. (JuliaLang/julia#60756)","category":"section"},{"location":"CHANGELOG/#2026-01-17","page":"CHANGELOG","title":"2026-01-17","text":"Commit: c8e2012\nDiff: 4cf9994...c8e2012\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-17\")'","category":"section"},{"location":"CHANGELOG/#Added-3","page":"CHANGELOG","title":"Added","text":"textDocument/definition now supports global bindings. Previously, go-to-definition for global variables couldn't find their definition sites since runtime reflection doesn't provide binding location information. Now it uses binding occurrence analysis to find definition sites across the package, benefiting from the binding occurrences cache.","category":"section"},{"location":"CHANGELOG/#Changed-3","page":"CHANGELOG","title":"Changed","text":"Improved workspace/symbol performance by enabling document symbol caching for files not currently open in the editor. Previously, only synced files (opened in editor) used the cache, causing repeated parsing for every workspace symbol search. The cache is now invalidated via workspace/didChangeWatchedFiles when unsynced files change on disk.\nImproved textDocument/references, textDocument/rename, and textDocument/documentHighlight performance for global bindings by caching binding occurrence analysis results per top-level expression. The cache persists across requests within the same package, so consecutive find-references, rename, or document highlight operations avoid redundant lowering.","category":"section"},{"location":"CHANGELOG/#2026-01-15","page":"CHANGELOG","title":"2026-01-15","text":"Commit: 4cf9994\nDiff: 54b3058...4cf9994\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-15\")'","category":"section"},{"location":"CHANGELOG/#Added-4","page":"CHANGELOG","title":"Added","text":"Implemented textDocument/documentSymbol for structured outline view in editors. Provides hierarchical symbol information including modules, functions, structs, and local variables with rich detail context.\n\n<center>\n<img alt=\"textDocument/documentSymbol\" src=\"https://github.com/user-attachments/assets/80b9d743-9a81-46e6-bb2b-692d8b6598b4\" />\n</center>\n\nImplemented workspace/symbol for workspace-wide symbol search, allowing quickly jumping to any function, type, or variable across the workspace. Results include rich context like function signatures for easier identification.\n\n<center>\n<img alt=\"workspace/symbol\" src=\"https://github.com/user-attachments/assets/7ed8b366-d72f-49ff-9dbd-5a18ef66c2b7\" />\n</center>","category":"section"},{"location":"CHANGELOG/#Changed-4","page":"CHANGELOG","title":"Changed","text":"Updated JuliaSyntax.jl and JuliaLowering.jl dependency versions to latest.","category":"section"},{"location":"CHANGELOG/#2026-01-11","page":"CHANGELOG","title":"2026-01-11","text":"Commit: 54b3058\nDiff: 8b3c9db...54b3058\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-11\")'","category":"section"},{"location":"CHANGELOG/#Fixed-3","page":"CHANGELOG","title":"Fixed","text":"Fixed cancellation not working properly for formatting requests (Fixed aviatesk/JETLS.jl#465)\nFixed diagnostic relatedInformation range not being localized for notebook cells","category":"section"},{"location":"CHANGELOG/#2026-01-10","page":"CHANGELOG","title":"2026-01-10","text":"Commit: 8b3c9db\nDiff: cbcdc3c...8b3c9db\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-10\")'","category":"section"},{"location":"CHANGELOG/#Added-5","page":"CHANGELOG","title":"Added","text":"Added lowering/captured-boxed-variable diagnostic that reports variables captured by closures requiring boxing. E.g.:\nfunction abmult1(r::Int)  # `r` is captured and boxed (JETLS lowering/captured-boxed-variable)\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r        # RelatedInformation: Closure at L5:9 captures `r`\n    return f\nend\n(aviatesk/JETLS.jl#452)","category":"section"},{"location":"CHANGELOG/#Changed-5","page":"CHANGELOG","title":"Changed","text":"Keyword argument name completion items are now sorted according to their order in the method definition.","category":"section"},{"location":"CHANGELOG/#Fixed-4","page":"CHANGELOG","title":"Fixed","text":"Fixed textDocument/diagnostic for notebook cells.\nFixed textDocument/formatting and textDocument/rangeFormatting for notebook cells (Fixed the first issue of aviatesk/JETLS.jl#442).\nReturn empty results instead of errors for LSP requests on documents that haven't been synchronized via textDocument/didOpen (Fixed the second issue of aviatesk/JETLS.jl#442).\nFixed lowering/undef-global-var diagnostic incorrectly reporting non-constant but defined symbols as undefined in the file-analysis mode.\nFixed cancellation not working for requests that use server-initiated progress (e.g., textDocument/formatting, textDocument/rename, textDocument/references). Previously, these requests were marked as handled immediately when the handler returned, causing $/cancelRequest to be ignored.\nFixed progress UI cancel button not being displayed for textDocument/formatting, textDocument/rangeFormatting, textDocument/references, and textDocument/rename requests. The server now properly handles both $/cancelRequest and window/workDoneProgress/cancel to abort these requests.","category":"section"},{"location":"CHANGELOG/#2026-01-09","page":"CHANGELOG","title":"2026-01-09","text":"Commit: cbcdc3c\nDiff: 368e0a1...cbcdc3c\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-09\")'","category":"section"},{"location":"CHANGELOG/#Fixed-5","page":"CHANGELOG","title":"Fixed","text":"Fixed lowering/undef-global-var diagnostic incorrectly reporting imported symbols from dependency packages as undefined. when !JETLS_DEV_MODE. (aviatesk/JETLS.jl#457)\nFixed false positive lowering/undef-global-var diagnostic for keyword slurp arguments with dependent defaults (e.g., f(; a=1, b=a, kws...)). (JuliaLang/julia#60600)","category":"section"},{"location":"CHANGELOG/#2026-01-08","page":"CHANGELOG","title":"2026-01-08","text":"Commit: 368e0a1\nDiff: c5f3c0d...368e0a1\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-08\")'","category":"section"},{"location":"CHANGELOG/#Added-6","page":"CHANGELOG","title":"Added","text":"Added lowering/undef-global-var diagnostic that reports undefined global variable references on document change (as you type). This provides faster feedback compared to inference/undef-global-var, which runs on save. The on-change diagnostic detects simple undefined references with accurate position information, while the on-save version detects a superset of undefined global binding references, including qualified references like Base.undefvar. (aviatesk/JETLS.jl#450)\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/7825c938-5dae-4bb8-9c84-b95e788461e8\" type=\"video/mp4\">\n</video>\n</center>\n\nMethod signature completion for function calls. When typing inside a function call (triggered by (, ,, or ), compatible method signatures are suggested based on already-provided arguments. Selecting a completion inserts remaining positional arguments as snippet placeholders with type annotations. When you select a completion item in the list, additional details such as inferred return type and documentation are displayed (resolved lazily for performance). (aviatesk/JETLS.jl#428)\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/19d320a6-459f-4788-9669-d3936920b625\" type=\"video/mp4\">\n</video>\n</center>\n\nKeyword argument name completion for function calls. When typing inside a function call (e.g., func(; |) or func(k|)), available keyword arguments are suggested with = appended. Already-specified keywords are excluded from suggestions, and the spacing around = follows the existing style in the call. (aviatesk/JETLS.jl#427)\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/d3cdecea-d2eb-4d14-9043-6bc62a6f2833\" type=\"video/mp4\">\n</video>\n</center>\n\nAdded completion.latex_emoji.strip_prefix configuration option to control prefix stripping in LaTeX/emoji completions. Some editors (e.g., Zed) don't handle backslash characters in the LSP sortText field, causing incorrect completion order. Set to true to strip prefixes, false to keep them. If not set, JETLS auto-detects based on client. The auto-detection covers only a limited set of known clients, so users experiencing sorting issues should explicitly set this option.\nAdded completion.method_signature.prepend_inference_result configuration option to control whether to prepend inferred return type information to the documentation of method signature completion items. In some editors (e.g., Zed), additional information like inferred return type displayed when an item is selected may be cut off in the UI when method signature text is long. Set to true to show return type in documentation. If not set, JETLS auto-detects based on client. The auto-detection covers only a limited set of known clients, so users experiencing visibility issues should explicitly set this option.\n\ntip: Tip\nHelp improve auto-detection:Some completion configuration options (e.g., completion.latex_emoji.strip_prefix, completion.method_signature.prepend_inference_result) use client-based auto-detection for default behavior. If explicitly setting these options clearly improves behavior for your client, consider submitting a PR to add your client to the auto-detection logic.\n\nAdded code actions to delete unused variable assignments. For unused local bindings like y = println(x), two new quick fix actions are now available:\n\"Delete assignment\": removes y =, leaving just println(x)\n\"Delete statement\": removes the entire assignment statement\nThese actions are not shown for (named)tuple destructuring patterns like x, y, z = func() where deletion would change semantics.","category":"section"},{"location":"CHANGELOG/#Changed-6","page":"CHANGELOG","title":"Changed","text":"Enhanced global completion items with detailed kind information ([function], [type], [module], etc.). When you select a completion item, these details are displayed (resolved lazily for performance). The visibility of these enhancements varies by client: VSCode updates only the CompletionItem.detail field (shown above documentation), while Zed is able to update all fields including CompletionItem.kind for richer presentation with label highlighting (combined with https://github.com/aviatesk/zed-julia/pull/1). (aviatesk/JETLS.jl#425)\nDemo with aviatesk/zed-julia\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/a39d7bc5-c46e-40c8-a9ee-0458b3abdcae\" type=\"video/mp4\">\n</video>\n</center>\n\nImproved signature help filtering when a semicolon is present in function calls. Methods that require more positional arguments than provided are now filtered out once the user enters the keyword argument region (e.g., g(42;│) no longer shows g(x, y) which requires 2 positional arguments). (aviatesk/JETLS.jl#426)\nSignature help and method completion now use type-based filtering. Method candidates are filtered based on the inferred types of already-provided arguments. For example, signature help and method completions triggered by typing sin(1,│ now shows only sin(::Real) instead of all sin methods. Global constants are also resolved (e.g., sin(gx,│) with const gx = 42 correctly infers Int). Note that local variable types are not yet resolved, (e.g., let x = 1; sin(x,│); end would still show all sin methods). (aviatesk/JETLS.jl#436)\nSignature help now displays the inferred argument type for the active parameter. The parameter documentation shows the passed argument expression and its type (e.g., p ← (arg) :: Int64).\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/a222a44d-9d46-435c-8759-8157005cfc38\" type=\"video/mp4\">\n</video>\n</center>\n\nUpdated JuliaSyntax.jl and JuliaLowering.jl dependency versions to latest.\nUpdated Revise.jl dependency version to v3.13.","category":"section"},{"location":"CHANGELOG/#Fixed-6","page":"CHANGELOG","title":"Fixed","text":"Improved type resolver robustness, eliminating UndefVarError messages that could appear in server logs during signature help. Fixed aviatesk/JETLS.jl#391. (aviatesk/JETLS.jl#435)\nFixed signature help parameter highlighting when cursor is not inside any argument. For positional arguments exceeding the parameter count, the last (vararg) parameter is now highlighted (e.g. println(stdout,\"foo\",\"bar\",│)). For keyword arguments after a semicolon, the next unspecified keyword parameter is highlighted (e.g., printstyled(\"foo\"; bold=true,│) highlights italic).","category":"section"},{"location":"CHANGELOG/#2026-01-01","page":"CHANGELOG","title":"2026-01-01","text":"Commit: c5f3c0d\nDiff: b61b6fa...c5f3c0d\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2026-01-01\")'","category":"section"},{"location":"CHANGELOG/#Fixed-7","page":"CHANGELOG","title":"Fixed","text":"Fixed method overwrite detection to handle both Core.CodeInfo and Expr source types, making the analysis more robust. (aviatesk/JETLS.jl#421)\nFixed toplevel/abstract-field diagnostic to report correct field locations for structs with <: subtyping syntax and const field modifiers. (aviatesk/JETLS.jl#422)","category":"section"},{"location":"CHANGELOG/#2025-12-31","page":"CHANGELOG","title":"2025-12-31","text":"Commit: b61b6fa\nDiff: afc5137...b61b6fa\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-31\")'","category":"section"},{"location":"CHANGELOG/#Added-7","page":"CHANGELOG","title":"Added","text":"Added diagnostic.allow_unused_underscore configuration option (default: true). When enabled, unused variable diagnostics (lowering/unused-argument and lowering/unused-local) are suppressed for names starting with _. (aviatesk/JETLS.jl#415)\nAdded code action to prefix unused variables with _. When triggered on an unused variable diagnostic, this quickfix inserts _ at the beginning of the variable name to suppress the warning. (aviatesk/JETLS.jl#416)\nAdded warning diagnostic for method overwrites (toplevel/method-overwrite). When a method with the same signature is defined multiple times within a package, a warning is reported at the overwriting definition with a link to the original definition. Addresses aviatesk/JETLS.jl#387. (aviatesk/JETLS.jl#417)\n\n<center>\n<img alt=\"toplevel/method-overwrite showcase\" src=\"https://github.com/user-attachments/assets/5c4aa6f7-ebd8-4e07-b3c6-ad6159a76508\">\n</center>\n\nAdded information diagnostic for abstract field types (toplevel/abstract-field). Reports when a struct field has an abstract type (e.g., Vector{Integer} or Pair{Int}), which often causes performance issues such as dynamic dispatch. (aviatesk/JETLS.jl#418, aviatesk/JETLS.jl#419)\n\n<center>\n<img alt=\"toplevel/abstract-field showcase\" src=\"https://github.com/user-attachments/assets/b5f925bb-d518-4e6c-893d-2f91fb1965f6\">\n</center>","category":"section"},{"location":"CHANGELOG/#Fixed-8","page":"CHANGELOG","title":"Fixed","text":"Added patch to vendored JuliaLowering to support @. macro expansion. This was addressed with a specific patch for the @. case, but many of these JuliaLowering macro compatibility issues are planned to be resolved generically in the future. Fixed aviatesk/JETLS.jl#409.","category":"section"},{"location":"CHANGELOG/#2025-12-19","page":"CHANGELOG","title":"2025-12-19","text":"Commit: afc5137\nDiff: c9c5729...afc5137\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-19\")'","category":"section"},{"location":"CHANGELOG/#Added-8","page":"CHANGELOG","title":"Added","text":"Added CHANGELOG page to the documentation.","category":"section"},{"location":"CHANGELOG/#Fixed-9","page":"CHANGELOG","title":"Fixed","text":"Fixed inference/undef-global-var diagnostic being unintentially reported for undefined global bindings in dependency packages.\nFixed syntax/lowering diagnostics not being refreshed when diagnostic configuration change via .JETLSConfig.toml or LSP configuration. The server now sends workspace/diagnostic/refresh request to prompt clients to re-pull diagnostics. Note that client support varies; e.g. VSCode refreshes textDocument/diagnostic in response, but Zed does not.","category":"section"},{"location":"CHANGELOG/#2025-12-18","page":"CHANGELOG","title":"2025-12-18","text":"Commit: c9c5729\nDiff: 048d9a5...c9c5729\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-18\")'","category":"section"},{"location":"CHANGELOG/#Added-9","page":"CHANGELOG","title":"Added","text":"Added inference/field-error diagnostic for detecting access to non-existent struct fields (e.g., x.propert when the field is property). Closed aviatesk/JETLS.jl#392.\nAdded inference/bounds-error diagnostic for detecting out-of-bounds field access by index (e.g., tpl[2] on a tpl::Tuple{Int}). Note that this diagnostic is for struct/tuple field access, not array indexing.\nAdded completion support for Julia keywords. Closed aviatesk/JETLS.jl#386.\nAdded hover documentation for Julia keywords.\nInitialization options can now be configured via .JETLSConfig.toml using the [initialization_options] section. See the documentation for details.\nAdded file rename support. When renaming a string literal that refers to a valid file path (e.g., in include(\"foo.jl\")), JETLS now renames both the file on disk and updates the string reference in the source code. Note that this feature only works when initiating rename from within the Julia source code; renaming files externally (e.g., via editor file explorer) will not automatically update code references.","category":"section"},{"location":"CHANGELOG/#Fixed-10","page":"CHANGELOG","title":"Fixed","text":"Small adjustments for using JETLS with Julia v1.12.3\nFixed false negative unused argument diagnostics for functions with keyword arguments. For example, func(a; kw=nothing) = kw now correctly reports a as unused. Fixed aviatesk/JETLS.jl#390.\nFixed stale diagnostics not being cleared when a file is closed or when test structure changes remove all diagnostics for a URI.\nFixed wrong message for diagnostic with multiple stack frames. The diagnostic message could be incorrectly overwritten when there are multiple stack frames, causing \"message must be set\" errors in VSCode. Fixed aviatesk/JETLS.jl#393.","category":"section"},{"location":"CHANGELOG/#Changed-7","page":"CHANGELOG","title":"Changed","text":"Completions now return no results when the prefix type is unknown. Previously, irrelevant completions were shown for expressions like obj.x where obj's type could not be resolved. Fixed aviatesk/JETLS.jl#389.\nInvalid initialization options are now reported to the user via editor notifications instead of only being logged to the server.","category":"section"},{"location":"CHANGELOG/#2025-12-12","page":"CHANGELOG","title":"2025-12-12","text":"Commit: 048d9a5\nDiff: 9b39829...048d9a5\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-12\")'","category":"section"},{"location":"CHANGELOG/#Added-10","page":"CHANGELOG","title":"Added","text":"Added textDocument/references support for bindings. Both local and global bindings are supported, although currently the support for global references is experimental and has some notable limitations:\nReferences can only be found within the same analysis unit. For example, when finding references to somebinding defined in PkgA/src/somefile.jl, usages in PkgA/src/ can be found, but usages in PkgA/test/ cannot be detected because test files are in a separate analysis unit.\nAliasing is not considered. Usages via using ..PkgA: somebinding as otherbinding or module-qualified access like PkgA.somebinding are not detected.\nAdded textDocument/rename support for global bindings. Similar to global references, this feature is experimental and has the same limitations regarding analysis unit boundaries and aliasing.","category":"section"},{"location":"CHANGELOG/#Fixed-11","page":"CHANGELOG","title":"Fixed","text":"Fixed false positive unused variable diagnostics in comprehensions with filter conditions. For example, [x for (i, x) in enumerate(xs) if isodd(i)] no longer incorrectly reports i as unused. Fixes aviatesk/JETLS.jl#360.","category":"section"},{"location":"CHANGELOG/#Changed-8","page":"CHANGELOG","title":"Changed","text":"Updated JuliaSyntax.jl and JuliaLowering.jl dependencies to the latest development versions, which fixes spurious lowering diagnostics that occurred in edge cases such as JuliaLang/julia#60309.","category":"section"},{"location":"CHANGELOG/#2025-12-08","page":"CHANGELOG","title":"2025-12-08","text":"Commit: 9b39829\nDiff: fd5f113...9b39829\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-08\")'","category":"section"},{"location":"CHANGELOG/#Added-11","page":"CHANGELOG","title":"Added","text":"Jupyter notebook support: JETLS now provides language features for Julia code cells in Jupyter notebooks. As shown in the demo below, all code cells are analyzed together as a single source, as if the notebook were a single Julia script. JETLS is aware of all cells, so features like go-to-definition, completions, and diagnostics work across cells just as they would in a regular Julia script.\nJETLS × notebook LSP demo\n\n<center>\n<video style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/b5bb5201-d735-4a37-b430-932b519254ee\" type=\"video/mp4\">\n</video>\n</center>","category":"section"},{"location":"CHANGELOG/#Fixed-12","page":"CHANGELOG","title":"Fixed","text":"Fixed UndefVarError during full analysis by updating the vendored JuliaInterpreter.jl to v0.10.9.\nFixed source location links in hover content to use comma-delimited format (#L<line>,<character>) instead of #L<line>C<character>. The previous format was not correctly parsed by VS Code - the column position was ignored. The new format follows VS Code's implementation and works with other LSP clients like Sublime Text's LSP plugin. Fixes aviatesk/JETLS.jl#281.","category":"section"},{"location":"CHANGELOG/#2025-12-06","page":"CHANGELOG","title":"2025-12-06","text":"Commit: fd5f113\nDiff: c23409d...fd5f113\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-06\")'","category":"section"},{"location":"CHANGELOG/#Fixed-13","page":"CHANGELOG","title":"Fixed","text":"TestRunner code lenses and code actions now properly wait for file cache population before being computed.","category":"section"},{"location":"CHANGELOG/#Changed-9","page":"CHANGELOG","title":"Changed","text":"Updated JuliaSyntax.jl and JuliaLowering to the latest development versions.","category":"section"},{"location":"CHANGELOG/#2025-12-05","page":"CHANGELOG","title":"2025-12-05","text":"Commit: c23409d\nDiff: aae52f5...c23409d\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-05\")'","category":"section"},{"location":"CHANGELOG/#Changed-10","page":"CHANGELOG","title":"Changed","text":"diagnostic.patterns from LSP config and file config are now merged instead of file config completely overriding LSP config. For patterns with the same pattern value, file config wins. Patterns unique to either source are preserved.","category":"section"},{"location":"CHANGELOG/#Fixed-14","page":"CHANGELOG","title":"Fixed","text":"Request handlers now wait for file cache to be populated instead of immediately returning errors. This fixes \"file cache not found\" errors that occurred when requests arrived before the cache was ready, particularly after opening files. (aviatesk/JETLS.jl#273,  aviatesk/JETLS.jl#274,  aviatesk/JETLS.jl#327)\nFixed glob pattern matching for diagnostic.patterns[].path: ** now correctly matches zero or more directory levels (e.g., test/**/*.jl matches test/testfile.jl), and wildcards no longer match hidden files/directories. (aviatesk/JETLS.jl#359)\n.JETLSConfig.toml is now only recognized at the workspace root. Previously, config files in subdirectories were also loaded, which was inconsistent with the documentation.\nClean up methods from previous analysis modules after re-analysis to prevent stale overload methods from appearing in signature help or completions.","category":"section"},{"location":"CHANGELOG/#Internal","page":"CHANGELOG","title":"Internal","text":"Added heap snapshot profiling support. Create a .JETLSProfile file in the workspace root to trigger a heap snapshot. The snapshot is saved as JETLS_YYYYMMDD_HHMMSS.heapsnapshot and can be analyzed using Chrome DevTools. See DEVELOPMENT.md's Profiling section for details.","category":"section"},{"location":"CHANGELOG/#2025-12-02","page":"CHANGELOG","title":"2025-12-02","text":"Commit: aae52f5\nDiff: f9b2c2f...aae52f5\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-12-02\")'","category":"section"},{"location":"CHANGELOG/#Added-12","page":"CHANGELOG","title":"Added","text":"Added support for LSP initializationOptions with the experimental n_analysis_workers option for configuring concurrent analysis worker tasks. See Initialization options for details.","category":"section"},{"location":"CHANGELOG/#Changed-11","page":"CHANGELOG","title":"Changed","text":"Parallelized signature analysis phase using Threads.@spawn, leveraging the thread-safe inference pipeline introduced in Julia v1.12. This parallelization happens automatically when Julia is started with multiple threads, independent of the newly added n_analysis_workers initialization option. With 4 threads (--threads=4,2 specifically), first-time analysis of CSV.jl improved from 30s to 18s (~1.7x faster), and JETLS.jl itself from 154s to 36s (~4.3x faster).","category":"section"},{"location":"CHANGELOG/#Fixed-15","page":"CHANGELOG","title":"Fixed","text":"Fixed handling of messages received before the initialize request per LSP 3.17 specification.\nFixed progress indicator not being cleaned up when analysis throws an error.","category":"section"},{"location":"CHANGELOG/#2025-11-30","page":"CHANGELOG","title":"2025-11-30","text":"Commit: f9b2c2f\nDiff: eda08b5...f9b2c2f\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-30\")'","category":"section"},{"location":"CHANGELOG/#Added-13","page":"CHANGELOG","title":"Added","text":"JETLS now automatically runs Pkg.resolve() and Pkg.instantiate() for packages that have not been instantiated yet (e.g., freshly cloned repositories). This allows full analysis to work immediately upon opening such packages. When no manifest file exists, JETLS first creates a versioned manifest (e.g., Manifest-v1.12.toml). This behavior is controlled by the full_analysis.auto_instantiate configuration option (default: true). Set it to false to disable.\nWhen full_analysis.auto_instantiate is disabled, JETLS now checks if the environment is instantiated and warns the user if not.","category":"section"},{"location":"CHANGELOG/#Fixed-16","page":"CHANGELOG","title":"Fixed","text":"Fixed error when receiving notifications after shutdown request. The server now silently ignores notifications instead of causing errors from invalid property access (which is not possible for notifications).\nFixed race condition in package environment detection when multiple files are opened simultaneously. Added global lock to activate_do to serialize environment switching operations. This fixes spurious \"Failed to identify package environment\" warnings.\nFixed document highlight and rename not working for function parameters annotated with @nospecialize or @specialize.","category":"section"},{"location":"CHANGELOG/#Internal-2","page":"CHANGELOG","title":"Internal","text":"Fixed Revise integration in development mode. The previous approach of dynamically loading Revise via Base.require didn't work properly because Revise assumes it's loaded from a REPL session. Revise is now a direct dependency that's conditionally loaded at compile time based on the JETLS_DEV_MODE flag.\nSignificantly refactored the full-analysis pipeline implementation. Modified the full-analysis pipeline behavior to output more detailed logs when JETLS_DEV_MODE is enabled.","category":"section"},{"location":"CHANGELOG/#2025-11-28","page":"CHANGELOG","title":"2025-11-28","text":"Commit: eda08b5\nDiff: 6ec51e1...eda08b5\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-28\")'","category":"section"},{"location":"CHANGELOG/#Changed-12","page":"CHANGELOG","title":"Changed","text":"Pinned installation now uses release tags (rev=\"YYYY-MM-DD\") instead of branch names (rev=\"releases/YYYY-MM-DD\"). The releases/YYYY-MM-DD branches will be deleted after merging since [sources] entries reference commit SHAs directly. Existing release branches (releases/2025-11-24 through releases/2025-11-27) will be kept until the end of December 2025 for backward compatibility.","category":"section"},{"location":"CHANGELOG/#Fixed-17","page":"CHANGELOG","title":"Fixed","text":"Fixed false lowering/macro-expansion-error diagnostics appearing before initial full-analysis completes. These diagnostics are now skipped until module context is available, then refreshed via workspace/diagnostic/refresh. Fixes aviatesk/JETLS.jl#279 and aviatesk/JETLS.jl#290. (aviatesk/JETLS.jl#333)","category":"section"},{"location":"CHANGELOG/#Removed","page":"CHANGELOG","title":"Removed","text":"Removed the deprecated runserver.jl script. Users should use the jetls executable app instead. See the 2025-11-24 release notes for migration details.","category":"section"},{"location":"CHANGELOG/#2025-11-27","page":"CHANGELOG","title":"2025-11-27","text":"Commit: 6ec51e1\nDiff: 6bc34f1...6ec51e1\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-27\")'","category":"section"},{"location":"CHANGELOG/#Added-14","page":"CHANGELOG","title":"Added","text":"Added --version (-v) option to the jetls CLI to display version information. The --help output now also includes the version. Version is stored in the JETLS_VERSION file and automatically updated during releases.\nAutomatic GitHub Release creation when release PRs are merged. You can view releases at https://github.com/aviatesk/JETLS.jl/releases. The contents are and will be extracted from this CHANGELOG.md.","category":"section"},{"location":"CHANGELOG/#Changed-13","page":"CHANGELOG","title":"Changed","text":"Updated CodeTracking.jl, LoweredCodeUtils and JET.jl dependencies to the latest development versions.","category":"section"},{"location":"CHANGELOG/#Internal-3","page":"CHANGELOG","title":"Internal","text":"Automation for release process: scripts/prepare-release.sh automates release branch creation, dependency vendoring, and PR creation.\nAutomatic CHANGELOG.md updates via CI when release PRs are merged.","category":"section"},{"location":"CHANGELOG/#2025-11-26","page":"CHANGELOG","title":"2025-11-26","text":"Commit: 6bc34f1\nDiff: 2be0cff...6bc34f1\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-26\")'","category":"section"},{"location":"CHANGELOG/#Changed-14","page":"CHANGELOG","title":"Changed","text":"Updated JuliaSyntax.jl and JuliaLowering.jl dependencies to the latest development versions.\nUpdated documentation deployment to use release as the default version. The documentation now has two versions in the selector: release (stable) and dev (development). The root URL redirects to /release/ by default. The release documentation index page shows the release date extracted from commit messages.","category":"section"},{"location":"CHANGELOG/#2025-11-25","page":"CHANGELOG","title":"2025-11-25","text":"Commit: 2be0cff\nDiff: fac4eaf...2be0cff\nInstallation:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-25\")'","category":"section"},{"location":"CHANGELOG/#Added-15","page":"CHANGELOG","title":"Added","text":"Added CI workflow for testing the vendored release environment. This validates that changes to master don't break the release branch. (aviatesk/JETLS.jl#321)\nAdded CI workflow for the release branch with tests and documentation deployment. Documentation for the release branch is now available at https://aviatesk.github.io/JETLS.jl/release/. (aviatesk/JETLS.jl#321)","category":"section"},{"location":"CHANGELOG/#Fixed-18","page":"CHANGELOG","title":"Fixed","text":"Fixed vendoring script to remove unused weakdeps and extensions from vendored packages. These could interact with user's package environment unexpectedly. Extensions that are actually used by JETLS are preserved with updated UUIDs. Fixes aviatesk/JETLS.jl#312. (aviatesk/JETLS.jl#320)","category":"section"},{"location":"CHANGELOG/#2025-11-24","page":"CHANGELOG","title":"2025-11-24","text":"Commit: fac4eaf","category":"section"},{"location":"CHANGELOG/#Changed-/-Breaking","page":"CHANGELOG","title":"Changed / Breaking","text":"Implemented environment isolation via dependency vendoring to prevent conflicts between JETLS dependencies and packages being analyzed. All JETLS dependencies are now vendored with rewritten UUIDs in the release branch, allowing JETLS to maintain its own isolated copies of dependencies. This resolves issues where version conflicts between JETLS and analyzed packages would prevent analysis. Users should install JETLS from the release branch using Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\"). (aviatesk/JETLS.jl#314)\nFor developers: See https://github.com/aviatesk/JETLS.jl/blob/master/DEVELOPMENT.md#release-process for details on the release process.\nMigrated the JETLS entry point from the runserver.jl script to the jetls executable app defined by JETLS.jl itself. This significantly changes how JETLS is installed and launched, while the new methods are generally simpler: (aviatesk/JETLS.jl#314)\nInstallation: Install the jetls executable app using:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\nThis installs the executable to ~/.julia/bin/jetls. Make sure ~/.julia/bin is in your PATH.\nUpdating: Update JETLS to the latest version by re-running the installation command:\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\nLaunching: Language clients should launch JETLS using the jetls executable with appropriate options. See https://aviatesk.github.io/JETLS.jl/release/launching/ for detailed launch options.\nThe VSCode language client jetls-client and Zed extension aviatesk/zed-julia has been updated accordingly.\nChanged diagnostic configuration schema from [diagnostic.codes] to [[diagnostic.patterns]] for more flexible pattern matching. (aviatesk/JETLS.jl#299)\nRenamed configuration section from [diagnostics] to [diagnostic] for consistency. (aviatesk/JETLS.jl#299)","category":"section"},{"location":"CHANGELOG/#Added-16","page":"CHANGELOG","title":"Added","text":"Added configurable diagnostic serveirty support with hierarchical diagnostic codes in \"category/kind\" format. Users can now control which diagnostics are displayed and their severity levels through fine-grained configuration. (aviatesk/JETLS.jl#298)\nAdded pattern-based diagnostic configuration supporting message-based matching in addition to code-based matching. Supports both literal and regex patterns with a four-tier priority system. (aviatesk/JETLS.jl#299)\nAdded file path-based filtering for diagnostic patterns. Users can specify glob patterns (e.g., \"test/**/*.jl\") to apply diagnostic configurations to specific files or directories. (aviatesk/JETLS.jl#313)\nAdded LSP codeDescription implementation with clickable documentation links for diagnostics. (aviatesk/JETLS.jl#298)\nAdded this change log. (aviatesk/JETLS.jl#316)","category":"section"},{"location":"CHANGELOG/#Fixed-19","page":"CHANGELOG","title":"Fixed","text":"Fixed UTF-8 position encoding to use byte offsets instead of character counts. This resolves misalignment issues in UTF-8-based editors like Helix while maintaining compatibility with UTF-16 editors like VS Code. (aviatesk/JETLS.jl#306)","category":"section"},{"location":"formatting/#Formatting","page":"Formatter integration","title":"Formatting","text":"JETLS provides document formatting support through integration with external formatting tools. By default, Runic.jl is used, but you can configure alternative formatters or use custom formatting executables.","category":"section"},{"location":"formatting/#Features","page":"Formatter integration","title":"Features","text":"Document formatting: Format entire Julia files\nRange formatting: Format selected code regions (Runic and custom formatters only)\nProgress notifications: Visual feedback during formatting operations for clients that support work done progress","category":"section"},{"location":"formatting/#Prerequisites","page":"Formatter integration","title":"Prerequisites","text":"JETLS supports preset formatters as well as custom formatting executables. For preset formatters, install your preferred formatter and ensure it's available in your system PATH:\n\nRunic (default):\njulia -e 'using Pkg; Pkg.Apps.add(\"Runic\")'\nJuliaFormatter (requires v2.2.0 or higher):\njulia -e 'using Pkg; Pkg.Apps.add(\"JuliaFormatter\")'\n\nNote that you need to manually make ~/.julia/bin available on the PATH environment for the formatter executables to be accessible. See https://pkgdocs.julialang.org/dev/apps/ for the details.\n\nFor custom formatters, no installation is required—simply configure the path to your executable in .JETLSConfig.toml (see the custom formatter section below).","category":"section"},{"location":"formatting/#Formatter-configuration","page":"Formatter integration","title":"Formatter configuration","text":"Configure the formatter using either a .JETLSConfig.toml file in your project root or via LSP configuration (see How to configure JETLS for details). The configuration supports three options:","category":"section"},{"location":"formatting/#Preset-\"Runic\"-(default)","page":"Formatter integration","title":"Preset \"Runic\" (default)","text":"formatter = \"Runic\"\n\nIn this case, JETLS will look for the runic executable and use it to perform formatting.\n\nThis is the default setting and doesn't require explicit configuration. Runic supports both document and range formatting.","category":"section"},{"location":"formatting/#Preset-\"JuliaFormatter\"","page":"Formatter integration","title":"Preset \"JuliaFormatter\"","text":"formatter = \"JuliaFormatter\"\n\nIn this case, JETLS will look for the jlfmt executable and use it to perform formatting.\n\nIf a .JuliaFormatter.toml configuration file is found in your project, jlfmt will use those settings. Otherwise, it uses default settings with formatting options provided by the editor client (such as tab size) when available.\n\nwarning: Warning\nNote that JuliaFormatter currently, as of v2.2.0, only supports full document formatting, not range formatting.","category":"section"},{"location":"formatting/#Custom-formatter","page":"Formatter integration","title":"Custom formatter","text":"[formatter.custom]\nexecutable = \"/path/to/custom-formatter\"\nexecutable_range = \"/path/to/custom-range-formatter\"\n\nCustom formatters should accept Julia code via stdin and output formatted code to stdout, following the same interface as runic:\n\nexecutable: Command for full document formatting. The formatter should read the entire Julia source code from stdin, format it completely, and write the formatted result to stdout. The exit code should be 0 on success.\nexecutable_range: Command for range formatting. The formatter should accept a --lines=START:END argument to format only the specified line range. It should read the entire document code from stdin and write the entire document code to stdout with only the specified region formatted. The rest of the document must remain unchanged.","category":"section"},{"location":"formatting/#Troubleshooting","page":"Formatter integration","title":"Troubleshooting","text":"If you see an error about the formatter not being found:\n\nEnsure you've installed the formatter as described above\nCheck that the formatter executable is in your system PATH by running which runic or which jlfmt\nFor custom formatters, verify the executable path specified in your settings\nRestart your editor to ensure it picks up the updated PATH or configuration","category":"section"},{"location":"launching/#Launching-JETLS","page":"Launching","title":"Launching JETLS","text":"This guide explains how to launch the JETLS language server using jetls serve and describes the available communication channels.","category":"section"},{"location":"launching/#The-jetls-executable","page":"Launching","title":"The jetls executable","text":"The jetls executable is the main entry point for JETLS, providing two commands:\n\njetls serve - Start the language server for editor integration (this page)\njetls check - Run diagnostics from the command line\n\nThe executable can be installed as an executable app via Pkg.jl:\n\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\n\njetls serve --help\n\nusing JETLS\nusing Markdown\nMarkdown.parse('`'^3 * '\\n' * JETLS.serve_help_message * '\\n' * '`'^3)","category":"section"},{"location":"launching/#Communication-channels","page":"Launching","title":"Communication channels","text":"jetls serve supports multiple communication channels between the client and server. Choose based on your environment and requirements:","category":"section"},{"location":"launching/#pipe-connect-/-pipe-listen-(Unix-domain-socket-/-named-pipe)","page":"Launching","title":"pipe-connect / pipe-listen (Unix domain socket / named pipe)","text":"Advantages: Complete isolation from stdin/stdout, preventing protocol corruption; fastest for local communication\nBest for: Local development, Remote SSH, WSL\nLimitations: Not suitable for cross-container communication\nNote: Client is responsible for socket file cleanup in both modes\n\njetls serve provides two pipe modes:","category":"section"},{"location":"launching/#pipe-connect","page":"Launching","title":"pipe-connect","text":"Server connects to a client-created socket. This is the mode used by the jetls-client VSCode extension and is generally easier to implement:\n\nClient creates and listens on the socket first\nClient spawns the server process\nServer immediately connects to the client's socket\nNo stdout monitoring required - simpler client implementation\n\nExample:\n\njetls serve --pipe-connect=/tmp/jetls.sock","category":"section"},{"location":"launching/#pipe-listen","page":"Launching","title":"pipe-listen","text":"Server creates and listens on a socket, then waits for the client to connect. This is the traditional LSP server mode:\n\nClient spawns the server process\nServer creates socket and prints <JETLS-PIPE-READY>/tmp/jetls.sock</JETLS-PIPE-READY> to stdout\nClient must monitor stdout for the readiness notification\nClient connects to the socket after receiving notification\n\nExample:\n\njetls serve --pipe-listen=/tmp/jetls.sock","category":"section"},{"location":"launching/#socket-(TCP)","page":"Launching","title":"socket (TCP)","text":"Advantages: Complete isolation from stdin/stdout, preventing protocol corruption; works across network boundaries; supports port forwarding\nBest for: Manual remote connection across different machines (without VSCode Remote); shared server accessed by multiple developers\nLimitations: May require firewall configuration; potentially less secure than local alternatives\n\nExample:\n\njetls serve --socket=7777\n\nThe server will print <JETLS-PORT>7777</JETLS-PORT> to stdout once it starts listening. This is especially useful when using --socket=0 for automatic port assignment, as the actual port number will be announced:\n\njetls serve --socket=0\n# Output: <JETLS-PORT>54321</JETLS-PORT>  (actual port assigned by OS)\n\nUse with SSH port forwarding to connect from a different machine:\n\nssh -L 8080:localhost:8080 user@remote\n# Then connect your local client to localhost:8080","category":"section"},{"location":"launching/#stdio","page":"Launching","title":"stdio","text":"Advantages: Simplest setup; maximum compatibility; works everywhere\nBest for: Dev containers; environments where pipe doesn't work\nLimitations: Risk of protocol corruption if any code writes to stdin/stdout\n\nExample:\n\njetls serve --stdio\n# or simply\njetls serve\n\nwarning: Warning\nWhen using stdio mode, any println(stdout, ...) in your code or dependency packages may corrupt the LSP protocol and break the connection. Prefer pipe or socket modes when possible.","category":"section"},{"location":"launching/#Client-process-monitoring","page":"Launching","title":"Client process monitoring","text":"The --clientProcessId option enables the server to monitor the client process for crash detection, where the server periodically checks whether the specified process is still alive. If the client crashes or terminates unexpectedly, the server will automatically shut down, ensuring proper cleanup even when the client cannot execute the normal LSP shutdown sequence.\n\nnote: Note\nWhen specified via command line, the process ID should match the processId field that the client sends in the LSP initialize request parameters.","category":"section"},{"location":"launching/#init-options","page":"Launching","title":"Initialization options","text":"JETLS accepts static initialization options that are set once at server startup and require a server restart to take effect. Unlike dynamic configuration that can be changed at runtime, these options configure fundamental server behavior.","category":"section"},{"location":"launching/#init-options/schema","page":"Launching","title":"Schema","text":"{\n  \"n_analysis_workers\": 1\n}","category":"section"},{"location":"launching/#init-options/reference","page":"Launching","title":"Reference","text":"","category":"section"},{"location":"launching/#init-options/n_analysis_workers","page":"Launching","title":"n_analysis_workers (experimental)","text":"Type: integer\nDefault: 1\nMinimum: 1\n\nNumber of concurrent analysis worker tasks for running full analysis.\n\nThe code loading phase must execute sequentially due to package environment and world age constraints. However, when multiple analysis units are open (e.g., package source code and test code), increasing n_analysis_workers may reduce overall analysis time: while one unit is in the signature analysis phase, another can begin code loading concurrently.\n\nwarning: Experimental\nThis option is experimental and may be removed or its semantics may be changed substantially in future versions as the full analysis architecture evolves.\n\nnote: Signature analysis parallelization\nThe signature analysis phase is parallelized automatically using Threads.@spawn when Julia is started with multiple threads. This parallelization is independent of n_analysis_workers and provides significant speedups (e.g., ~4x faster with 4 threads for large packages).","category":"section"},{"location":"launching/#init-options/configure","page":"Launching","title":"How to configure initialization options","text":"Initialization options can be configured via:\n\nEditor-specific settings\nThe [initialization_options] section in .JETLSConfig.toml\n\nWhen both sources are present, file-based configuration takes precedence (file > client > default), as like JETLS configuration priority.","category":"section"},{"location":"launching/#init-options/file-config","page":"Launching","title":"File-based configuration","text":"Configure initialization options in .JETLSConfig.toml at your project root:\n\n[initialization_options]\nn_analysis_workers = 2\n\nThis method is client-agnostic and can be easily committed to version control.","category":"section"},{"location":"launching/#init-options/client-config","page":"Launching","title":"Client configuration","text":"The method and format for specifying initialization options varies by editor. Consult your editor's documentation on how to configure LSP initialization options. Below are examples for VSCode and Zed.\n\nIf your editor does not support specifying initialization options, use the file-based configuration instead.","category":"section"},{"location":"launching/#init-options/client-config/vscode","page":"Launching","title":"VSCode (jetls-client extension)","text":"Configure initialization options in VSCode's settings.json:\n\n{\n  \"jetls-client.initializationOptions\": {\n    \"n_analysis_workers\": 2\n  }\n}","category":"section"},{"location":"launching/#init-options/client-config/zed","page":"Launching","title":"Zed (aviatesk/zed-julia extension)","text":"Configure initialization options in Zed's settings.json:\n\n{\n  \"lsp\": {\n    \"JETLS\": {\n      \"initialization_options\": {\n        \"n_analysis_workers\": 2\n      }\n    }\n  }\n}","category":"section"},{"location":"cli-check/#cli-check","page":"Diagnostic CLI","title":"Diagnostic CLI","text":"The jetls check command runs JETLS diagnostics on Julia files from the command line, without requiring an editor or LSP client. This is useful for CI pipelines, pre-commit hooks, and workflows where editor integration is not available.\n\nFor details on what each diagnostic code means, see the Diagnostic reference.","category":"section"},{"location":"cli-check/#cli-check/usage","page":"Diagnostic CLI","title":"Basic usage","text":"# Check a package source file\njetls check src/SomePkg.jl\n\n# Check multiple files\njetls check src/SomePkg.jl test/runtests.jl\n\n# Check multiple files with multi threads\njetls --threads=4,2 -- check src/SomePkg.jl test/runtests.jl","category":"section"},{"location":"cli-check/#cli-check/reference","page":"Diagnostic CLI","title":"Command reference","text":"jetls check --help\n\nusing JETLS\nusing Markdown\nMarkdown.parse('`'^3 * '\\n' * JETLS.check_help_message * '\\n' * '`'^3)","category":"section"},{"location":"cli-check/#cli-check/input","page":"Diagnostic CLI","title":"Input files and analysis mode","text":"Currently, jetls check accepts only file paths as input (not directories). The analysis mode is determined by the file's location within the directory structure:\n\nPackage source files (src/SomePkg.jl): Analyzed in package context with full type inference\nTest files (test/*.jl): Analyzed in test context\nStandalone scripts: Analyzed as scripts\n\nFor example, when analyzing package code, run jetls check from the package root directory:\n\n# Correct: run from package root\ncd /path/to/MyPkg\njetls check src/SomePkg.jl\n\n# Incorrect: running from src/ directory won't detect package context\ncd /path/to/MyPkg/src\njetls check SomePkg.jl  # May not work as expected\n\nThe working directory (or --root path) is used to locate Project.toml for package context detection and .JETLSConfig.toml for configuration.","category":"section"},{"location":"cli-check/#cli-check/options","page":"Diagnostic CLI","title":"Options","text":"","category":"section"},{"location":"cli-check/#cli-check/options/root","page":"Diagnostic CLI","title":"--root=<path>","text":"Sets the root path for configuration file lookup and relative path display. By default, the current working directory is used.\n\nWhen specified, JETLS will:\n\nLook for .JETLSConfig.toml in the specified root directory\nDisplay file paths relative to this root in diagnostic output\n\n# Use project root for configuration\njetls check --root=/path/to/project src/SomePkg.jl\n\n# Useful when running from a different directory\ncd /tmp && jetls check --root=/path/to/project /path/to/project/src/SomePkg.jl","category":"section"},{"location":"cli-check/#cli-check/options/context-lines","page":"Diagnostic CLI","title":"--context-lines=<n>","text":"Controls how many lines of source code context are shown around each diagnostic. Default is 2.\n\n# Show more context\njetls check --context-lines=5 src/SomePkg.jl\n\n# Show no context (just the diagnostic line)\njetls check --context-lines=0 src/SomePkg.jl","category":"section"},{"location":"cli-check/#cli-check/options/exit-severity","page":"Diagnostic CLI","title":"--exit-severity=<level>","text":"Sets the minimum severity level that causes a non-zero exit code. This is useful for CI pipelines where you want to fail only on certain severity levels.\n\nAvailable levels (from most to least severe):\n\nerror - Only errors cause exit code 1\nwarn (default) - Warnings and errors cause exit code 1\ninfo - Information, warnings, and errors cause exit code 1\nhint - All diagnostics cause exit code 1\n\n# Only fail CI on errors\njetls check --exit-severity=error src/SomePkg.jl\n\n# Fail CI on any diagnostic\njetls check --exit-severity=hint src/SomePkg.jl","category":"section"},{"location":"cli-check/#cli-check/options/show-severity","page":"Diagnostic CLI","title":"--show-severity=<level>","text":"Sets the minimum severity level to display in the output. Diagnostics below this level are hidden from the output but may still affect the exit code (depending on --exit-severity).\n\nAvailable levels (from most to least severe):\n\nerror - Only show errors\nwarn - Show warnings and errors\ninfo - Show information, warnings, and errors\nhint (default) - Show all diagnostics\n\n# Only display warnings and errors (hide info and hints)\njetls check --show-severity=warn src/SomePkg.jl\n\n# Show all diagnostics but only fail on errors\njetls check --show-severity=hint --exit-severity=error src/SomePkg.jl","category":"section"},{"location":"cli-check/#cli-check/options/progress","page":"Diagnostic CLI","title":"--progress=<mode>","text":"Controls how progress is displayed during analysis.\n\nAvailable modes:\n\nauto (default) - Uses spinner for interactive terminals, simple output otherwise\nfull - Always show animated spinner with detailed progress\nsimple - One line per file (e.g., Analyzing [1/5] src/foo.jl...)\nnone - No progress output\n\n# Suppress progress for cleaner CI logs\njetls check --progress=none src/SomePkg.jl\n\n# Force simple output even in terminal\njetls check --progress=simple src/SomePkg.jl","category":"section"},{"location":"cli-check/#cli-check/options/julia-flags","page":"Diagnostic CLI","title":"Julia runtime flags","text":"Since jetls is an executable Julia app, you can pass Julia runtime flags before -- to configure the Julia runtime. This is especially useful for controlling threading behavior. JETLS's signature analysis phase is parallelized, so increasing thread count may improve analysis performance.\n\n# Run with 4 default threads and 2 interactive threads\njetls --threads=4,2 -- check src/SomePkg.jl\n\nFor more details on available runtime flags, see the Pkg documentation on runtime flags.","category":"section"},{"location":"cli-check/#cli-check/configuration","page":"Diagnostic CLI","title":"Configuration","text":"jetls check loads .JETLSConfig.toml from the root path (specified by --root, or the current working directory by default). This is the same configuration file used by the language server, and includes:\n\nDiagnostic severity overrides\nPattern-based diagnostic filtering\nPath-specific rules\n\nExample configuration to suppress certain diagnostics in CI:\n\n.JETLSConfig.toml\n\n# Ignore unused arguments in test files\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"off\"\npath = \"test/**/*.jl\"\n\nFor complete configuration options, see the JETLS configuration page.","category":"section"},{"location":"diagnostic/#diagnostic","page":"Diagnostic","title":"Diagnostic","text":"JETLS reports various diagnostic messages (errors, warnings, hints) to help you catch potential issues in your Julia code. Each diagnostic has a unique code that identifies its category and type.\n\nThis document describes all available diagnostic codes, their meanings, default severity levels, and how to configure them to match your project's needs.","category":"section"},{"location":"diagnostic/#diagnostic/code","page":"Diagnostic","title":"Codes","text":"JETLS reports diagnostics using hierarchical codes in the format \"category/kind\", following the LSP specification. This structure allows fine-grained control over which diagnostics to show and at what severity level through configuration.\n\nAll available diagnostic codes are listed below. Each category (e.g., syntax/*, lowering/*) contains one or more specific diagnostic codes:\n\nPages = [\"diagnostic.md\"]\nDepth = 3:4","category":"section"},{"location":"diagnostic/#diagnostic/severity","page":"Diagnostic","title":"Severity levels","text":"Each diagnostic has a severity level that indicates how serious the issue is. JETLS supports four severity levels defined by the LSP specification:\n\nError (1): Critical issues that prevent code from working correctly. Most LSP clients display these with red underlines and error markers.\nWarning (2): Potential problems that should be reviewed. Typically shown with yellow/orange underlines and warning markers.\nInformation (3): Informational messages about code that may benefit from attention. Often displayed with blue underlines or subtle markers.\nHint (4): Suggestions for improvements or best practices. Usually shown with the least intrusive visual indicators.\n\nHow diagnostics are displayed depends on your LSP client (VS Code, Neovim, etc.), but most clients use color-coded underlines and gutter markers that correspond to these severity levels.\n\nYou can change the severity of any diagnostic by configuring diagnostic section. Additionally, JETLS supports disabling diagnostics entirely using the special severity value \"off\" (or 0).","category":"section"},{"location":"diagnostic/#diagnostic/source","page":"Diagnostic","title":"Sources","text":"JETLS uses different diagnostic channels to balance analysis accuracy with response latency. Lightweight checks run as you edit for immediate feedback, while deeper analysis runs on save to avoid excessive resource consumption.\n\nEach diagnostic has a source field that identifies which diagnostic channel it comes from. This section explains what each source means, helping you understand when diagnostics update. Additionally, some editors also allow filtering diagnostics by source.\n\ninfo: Info\nThis section contains references to LSP protocol details. You don't need to understand these details to use JETLS effectively - the key takeaway is simply that different diagnostics update at different times (as you edit, when you save, or when you run tests via TestRunner integration).\n\nJETLS uses three diagnostic sources:\n\nJETLS/live: Diagnostics available on demand via the pull model diagnostic channels textDocument/diagnostic (for open files) and workspace/diagnostic (for unopened files when diagnostic.all_files is enabled). Most clients request these as you edit, providing real-time feedback without requiring a file save. Includes syntax errors and lowering-based analysis (syntax/*, lowering/*).\nJETLS/save: Diagnostics published by JETLS after on-save full analysis via the push model channel textDocument/publishDiagnostics. These run full analysis including type inference and require loading your code. Includes top-level errors and inference-based analysis (toplevel/*, inference/*).\nJETLS/extra: Diagnostics from external sources like the TestRunner integration (testrunner/*). Published via textDocument/publishDiagnostics.","category":"section"},{"location":"diagnostic/#diagnostic/reference","page":"Diagnostic","title":"Reference","text":"This section provides detailed explanations for each diagnostic code. For every diagnostic, you'll find:\n\nA description of what the diagnostic detects\nIts default severity level and source\nCode examples demonstrating when the diagnostic is reported\nExample diagnostic messages (shown in code comments)\n\nHere is a summary table of the diagnostics explained in this section:\n\nCode Default Severity Source Description\nsyntax/parse-error Error JETLS/live Syntax parsing errors detected by JuliaSyntax.jl\nlowering/error Error JETLS/live General lowering errors\nlowering/macro-expansion-error Error JETLS/live Errors during macro expansion\nlowering/unused-argument Information JETLS/live Function arguments that are never used\nlowering/unused-local Information JETLS/live Local variables that are assigned but never read\nlowering/undef-global-var Warning JETLS/live References to undefined global variables\nlowering/undef-local-var Warning/Information JETLS/live References to undefined local variables\nlowering/captured-boxed-variable Information JETLS/live Variables captured by closures that require boxing\nlowering/unused-import Information JETLS/live Imported names that are never used\nlowering/unsorted-import-names Hint JETLS/live Import/export names not sorted alphabetically\ntoplevel/error Error JETLS/save Errors during code loading\ntoplevel/method-overwrite Warning JETLS/save Method definitions that overwrite previous ones\ntoplevel/abstract-field Information JETLS/save Struct fields with abstract types\ninference/undef-global-var Warning JETLS/save References to undefined global variables\ninference/field-error Warning JETLS/save Access to non-existent struct fields\ninference/bounds-error Warning JETLS/save Out-of-bounds field access by index\ninference/method-error Warning No matching method found for function calls \ntestrunner/test-failure Error JETLS/extra Test failures from TestRunner integration","category":"section"},{"location":"diagnostic/#diagnostic/reference/syntax","page":"Diagnostic","title":"Syntax diagnostic (syntax/*)","text":"","category":"section"},{"location":"diagnostic/#diagnostic/reference/syntax/parse-error","page":"Diagnostic","title":"Syntax parse error (syntax/parse-error)","text":"Default severity: Error\n\nSyntax parsing errors detected by JuliaSyntax.jl. These indicate invalid Julia syntax that prevents the code from being parsed.\n\nExample:\n\nfunction parse_error(x)\n    println(x  # Expected `)` or `,` (JETLS syntax/parse-error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering","page":"Diagnostic","title":"Lowering diagnostic (lowering/*)","text":"Lowering diagnostics are detected during Julia's lowering phase, which transforms parsed syntax into a simpler intermediate representation.","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/error","page":"Diagnostic","title":"Lowering error (lowering/error)","text":"Default severity: Error\n\nGeneral lowering errors that don't fit into more specific categories.\n\nExample:\n\nfunction lowering_error(x)\n    $(x)  # `$` expression outside string or quote block (JETLS lowering/error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/macro-expansion-error","page":"Diagnostic","title":"Macro expansion error (lowering/macro-expansion-error)","text":"Default severity: Error\n\nErrors that occur when expanding macros during the lowering phase.\n\nExample:\n\nfunction macro_expand_error()\n    @undefined_macro ex  # Macro name `@undefined_macro` not found (JETLS lowering/macro-expansion-error)\nend\n\nErrors that occur during actual macro expansion are also reported:\n\nmacro myinline(ex)\n    Meta.isexpr(ex, :function) || error(\"Expected long function definition\")\n    return :(@inline $ex)\nend\n@myinline callsin(x) = sin(x)  # Error expanding macro\n                               # Expected long function definition (JETLS lowering/macro-expansion-error)","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/unused-argument","page":"Diagnostic","title":"Unused argument (lowering/unused-argument)","text":"Default severity: Information\n\nFunction arguments that are declared but never used in the function body.\n\nBy default, arguments with names starting with _ are not reported; see allow_unused_underscore.\n\nExample:\n\nfunction unused_argument(x, y)  # Unused argument `y` (JETLS lowering/unused-argument)\n    return x + 1\nend\n\ntip: Code action available\nYou can use the \"Prefix with '_'\" code action to quickly rename unused arguments, indicating they are intentionally unused.","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/unused-local","page":"Diagnostic","title":"Unused local variable (lowering/unused-local)","text":"Default severity: Information\n\nLocal variables that are assigned but never read.\n\nBy default, variables with names starting with _ are not reported; see allow_unused_underscore.\n\nExample:\n\nfunction unused_local()\n    x = 10  # Unused local binding `x` (JETLS lowering/unused-local)\n    return println(10)\nend\n\ntip: Code action available\nSeveral code actions are available for this diagnostic:\"Prefix with '_'\" to indicate the variable is intentionally unused\n\"Delete assignment\" to remove only the left-hand side (keeping the right-hand side expression)\n\"Delete statement\" to remove the entire assignment statement","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/undef-global-var","page":"Diagnostic","title":"Undefined global variable (lowering/undef-global-var)","text":"Default severity: Warning\n\nReferences to undefined global variables, detected during lowering analysis. This diagnostic provides immediate feedback as you type.\n\nExample:\n\nfunction undef_global_var()\n    ret = sin(undefined_var)  # `Main.undefined_var` is not defined (JETLS lowering/undef-global-var)\n    return ret\nend\n\nThis diagnostic detects simple undefined global variable references. For more comprehensive detection (including qualified references like Base.undefvar), see inference/undef-global-var (source: JETLS/save).","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/undef-local-var","page":"Diagnostic","title":"Undefined local variable (lowering/undef-local-var)","text":"Default severity: Warning or Information\n\nReferences to local variables that may be used before being defined. This diagnostic provides immediate feedback based on CFG-aware analysis on lowered code.\n\nThe severity depends on the certainty of the undefined usage:\n\nWarning: The variable is definitely used before any assignment (strict undef - guaranteed UndefVarError at runtime)\nInformation: The variable may be undefined depending on control flow (e.g., assigned only in one branch of an if statement)\n\nExamples:\n\nfunction strict_undef()\n    println(x)  # Variable `x` is used before it is defined (JETLS lowering/undef-local-var)\n                # Severity: Warning (strict undef)\n    x = 1       # RelatedInformation: `x` is defined here\n    return x\nend\n\nfunction maybe_undef(cond)\n    if cond\n        y = 1   # RelatedInformation: `y` is defined here\n    end\n    return y  # Variable `y` may be used before it is defined (JETLS lowering/undef-local-var)\n              # Severity: Information (maybe undef)\nend\n\nThe diagnostic is reported at the first use location, with relatedInformation pointing to definition sites to help understand the control flow.\n\ntip: Workaround: Using `@isdefined` guard\nWhen a variable is conditionally assigned, you can rewrite the program logic using @isdefined so that the compiler can track the definedness:function guarded(cond)\n    if cond\n        y = 42\n    end\n    if @isdefined(y)\n        return sin(y)  # No diagnostic: compiler knows `y` is defined here\n    end\nend\n\ntip: Workaround: Using `@assert @isdefined` as a hint\nThere are cases where you know a variable is always defined at a certain point, but the analysis cannot prove it. This includes correlated conditions, complex control flow, or general runtime invariants that the compiler cannot figure out statically. In such cases, you can use @assert @isdefined(var) \"...\" as a hint:function correlated(cond)\n    if cond\n        y = 42\n    end\n    if cond\n        # The analysis reports \"may be undefined\" because it doesn't track\n        # that `cond` is the same in both branches\n        @assert @isdefined(y) \"Assertion to tell the compiler about the definedness of this variable\"\n        return sin(y)  # No diagnostic after the assertion\n    end\nendThis hint allows the compiler to avoid generating unnecessary UndefVarError handling code, and also serves as documentation that you've verified the variable is defined at this point.","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/captured-boxed-variable","page":"Diagnostic","title":"Captured boxed variable (lowering/captured-boxed-variable)","text":"Default severity: Information\n\nReported when a variable is captured by a closure and requires \"boxing\" due to being assigned multiple times. Captured boxed variables are stored in heap-allocated containers (a.k.a. Core.Box), which can cause type instability and hinder compiler optimizations.[perftip]\n\n[perftip]: For detailed information about how captured variables affect performance, see Julia's Performance Tips on captured variables.\n\nExample:\n\nfunction captured_variable()\n    x = 1           # `x` is captured and boxed (JETLS lowering/captured-boxed-variable)\n    f = () ->\n        println(x)  # RelatedInformation: Closure at L3:9 captures `x`\n    x = 2           # (`x` is reassigned after capture)\n    return f\nend\n\nThe diagnostic includes relatedInformation showing where the variable is captured:\n\nfunction multi_capture()\n    x = 1               # `x` is captured and boxed (JETLS lowering/captured-boxed-variable)\n    f = () ->\n        println(x)      # RelatedInformation: Closure at L3:9 captures `x`\n    g = () ->\n        println(x + 1)  # RelatedInformation: Closure at L5:9 captures `x`\n    x = 2\n    return f, g\nend\n\nVariables captured by closures but assigned only once before closure definition do not require boxing and are not reported:\n\nfunction not_boxed()\n    x = 1\n    f = () -> x  # OK: `x` is only assigned once\n    return f\nend\n\ntip: Workaround\nWhen you need to capture a variable that changes, consider using a let block:function with_let()\n    x = 1\n    f = let x = x\n        () -> x  # Captures the value of `x` at this point\n    end\n    x = 2\n    return f()  # Returns 1, not 2\nendor mutable container like Ref to avoid direct assignment to the captured variable:function with_mut()\n    x = Ref(1)\n    f = () -> x[]\n    x[] = 2\n    return f()\nend\n\nwarning: Box optimization difference from the flisp lowerer\nThe generation of captured boxes is an implementation detail of the code lowerer (JuliaLowering.jl) used internally by JETLS, and the conditions under which captured boxes are created may change in the future. The control flow dominance analysis used for captured variable detection in the current JuliaLowering.jl is quite primitive, so captured boxes may occur even when programmers don't expect them. Also note that the cases where the flisp lowerer (a.k.a. code_lowered) generates Core.Box do not necessarily match the cases where JETLS reports captured boxes.","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/unused-import","page":"Diagnostic","title":"Unused import (lowering/unused-import)","text":"Default severity: Information\n\nReported when an explicitly imported name is never used within the same module space. This diagnostic helps identify unnecessary imports that can be removed to keep your code clean.\n\nExample:\n\nusing Base: sin, cos  # Unused import `cos` (JETLS lowering/unused-import)\n\nexamplefunc() = sin(1.0)  # Only `sin` is used\n\nThe diagnostic is reported for explicit imports (using M: name or import M: name), not for bulk imports like using M which bring in all exported names.\n\nThis diagnostic scans all files within the module space to detect usages, so an import is only reported as unused if the name is not used anywhere in your module.\n\ntip: Code action available\nUse the \"Remove unused import\" code action to delete the unused name. If it's the only name in the statement, the entire statement is removed.\n\nwarning: Limitation\nUsages introduced only through macro expansion cannot be detected. For example, in the following code, sin appears unused even though it is used inside the macro-generated code:using Base: sin  # Incorrectly reported as unused\n\nmacro gensincall(x)\n    :(sin($(esc(x))))\nend\n@gensincall 42Workarounds include using the binding directly in the macro body:macro gensincall(x)\n    f = sin  # `sin` is used here\n    :($f($(esc(x))))\nendor passing the binding as part of the macro argument:macro gencall(ex)\n    :($(esc(ex)))\nend\n@gencall sin(42)  # `sin` is used here","category":"section"},{"location":"diagnostic/#diagnostic/reference/lowering/unsorted-import-names","page":"Diagnostic","title":"Unsorted import names (lowering/unsorted-import-names)","text":"Default severity: Hint\n\nReported when names in import, using, export, or public statements are not sorted alphabetically. This is a style diagnostic that helps maintain consistent ordering of imports and exports.\n\nExpected sort order:\n\nCase-sensitive comparison (A < Z < a < z)\nFor as expressions like using Foo: bar as baz, sorted by original name (bar), not the alias\nRelative imports: dots are included in the sort key (..Base < Base < Core)\n\nExample:\n\nimport Foo: c, a, b  # Names are not sorted alphabetically (JETLS lowering/unsorted-import-names)\n\nexport bar, @foo  # Names are not sorted alphabetically (JETLS lowering/unsorted-import-names)\n\ntip: Code action available\nThe \"Sort import names\" code action automatically fixes the ordering. When the sorted result exceeds 92 characters ( Julia's conventional maximum line length), the code action wraps to multiple lines with 4-space continuation indent.","category":"section"},{"location":"diagnostic/#diagnostic/reference/toplevel","page":"Diagnostic","title":"Top-level diagnostic (toplevel/*)","text":"Top-level diagnostics are reported by JETLS's full analysis feature (source: JETLS/save), which runs when you save a file. To prevent excessive analysis on frequent saves, JETLS uses a debounce mechanism. See the [full_analysis] debounce configuration documentation to adjust the debounce period.","category":"section"},{"location":"diagnostic/#diagnostic/reference/toplevel/error","page":"Diagnostic","title":"Top-level error (toplevel/error)","text":"Default severity: Error\n\nErrors that occur when JETLS loads your code for analysis. This diagnostic is commonly reported in several scenarios:\n\nMissing package dependencies (the most frequent cause)\nType definition failures\nReferences to undefined names at the top level\nOther errors during module evaluation\n\nExamples:\n\nstruct ToplevelError  # UndefVarError: `Unexisting` not defined in `JETLS`\n                      # Suggestion: check for spelling errors or missing imports. (JETLS toplevel/error)\n    x::Unexisting\nend\n\nusing UnexistingPkg  # Package JETLS does not have UnexistingPkg in its dependencies:\n                     # - You may have a partially installed environment. Try `Pkg.instantiate()`\n                     # to ensure all packages in the environment are installed.\n                     # - Or, if you have JETLS checked out for development and have\n                     # added UnexistingPkg as a dependency but haven't updated your primary\n                     # environment's manifest file, try `Pkg.resolve()`.\n                     # - Otherwise you may need to report an issue with JETLS (JETLS toplevel/error)\n\nThese errors prevent JETLS from fully analyzing your code, which means Inference diagnostic will not be available until the top-level errors are resolved. To fix these errors, ensure your package environment is properly set up by running Pkg.instantiate() in your package directory, and verify that your package can be loaded successfully in a Julia REPL.","category":"section"},{"location":"diagnostic/#diagnostic/reference/toplevel/method-overwrite","page":"Diagnostic","title":"Method overwrite (toplevel/method-overwrite)","text":"Default severity: Warning\n\nReported when a method with the same signature is defined multiple times within a package. This typically indicates an unintentional redefinition that overwrites the previous method.\n\nExample:\n\nfunction duplicate(x::Int)\n    return x + 1\nend\n\nfunction duplicate(x::Int, y::Int=2)  # Method definition duplicate(x::Int) in module MyPkg overwritten\n                                      # (JETLS toplevel/method-overwrite)\n    return x + y\nend\n\nThe diagnostic includes a link to the original definition location via relatedInformation, making it easy to navigate to the first definition.","category":"section"},{"location":"diagnostic/#diagnostic/reference/toplevel/abstract-field","page":"Diagnostic","title":"Abstract field type (toplevel/abstract-field)","text":"Default severity: Information\n\nReported when a struct field has an abstract type, which can cause performance issues due to type instability. Storing values in abstractly-typed fields often prevents the compiler from generating optimized code.\n\nExample:\n\nstruct MyStruct\n    xs::Vector{Integer}  # `MyStruct` has abstract field `xs::Vector{Integer}`\n                         # (JETLS toplevel/abstract-field)\nend\n\nstruct AnotherStruct\n    data::AbstractVector{Int}  # `AnotherStruct` has abstract field `data::AbstractVector{Int}`\n                               # (JETLS toplevel/abstract-field)\nend\n\nTo fix this, use concrete types or parameterize your struct:\n\nstruct MyStruct\n    xs::Vector{Int}  # Concrete element type\nend\n\nstruct AnotherStruct{T<:AbstractVector{Int}}\n    data::T  # Parameterized field allows concrete types\nend\n\ntip: Tip\nIf you intentionally use abstract field types (e.g., in cases where data types are inherently only known at compile time[nospecializetip]), you can suppress this diagnostic using pattern-based configuration:[[diagnostic.patterns]]\npattern = \"`MyStruct` has abstract field `.*`\"\nmatch_by = \"message\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\n[nospecializetip]: For such cases, you can add @nospecialize to the use-site methods to allow them to handle abstract data types while avoiding excessive compilation.","category":"section"},{"location":"diagnostic/#diagnostic/reference/inference","page":"Diagnostic","title":"Inference diagnostic (inference/*)","text":"Inference diagnostics use JET.jl to perform type-aware analysis and detect potential errors through static analysis. These diagnostics are reported by JETLS's full analysis feature (source: JETLS/save), which runs when you save a file (similar to Top-level diagnostic).","category":"section"},{"location":"diagnostic/#diagnostic/reference/inference/undef-global-var","page":"Diagnostic","title":"Undefined global variable (inference/undef-global-var)","text":"Default severity: Warning\n\nReferences to undefined global variables, detected through full analysis. This diagnostic can detect comprehensive cases including qualified references (e.g., Base.undefvar). Position information is reported on a line basis.\n\nExample:\n\nfunction undef_global_var()\n    return undefined_global  # `undefined_global` is not defined (JETLS inference/undef-global-var)\nend\n\nFor faster feedback while editing, see lowering/undef-global-var (source: JETLS/live), which reports a subset of undefined variable cases with accurate position information.","category":"section"},{"location":"diagnostic/#diagnostic/reference/inference/field-error","page":"Diagnostic","title":"Field error (inference/field-error)","text":"Default severity: Warning\n\nAccess to non-existent struct fields. This diagnostic is reported when code attempts to access a field that doesn't exist on a struct type.\n\nExample:\n\nstruct MyStruct\n    property::Int\nend\nfunction field_error()\n    x = MyStruct(42)\n    return x.propert  # FieldError: type MyStruct has no field `propert`, available fields: `property` (JETLS inference/field-error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/reference/inference/bounds-error","page":"Diagnostic","title":"Bounds error (inference/bounds-error)","text":"Default severity: Warning\n\nOut-of-bounds field access by index. This diagnostic is reported when code attempts to access a struct field using an integer index that is out of bounds, such as getfield(x, i) or tuple indexing tpl[i].\n\nnote: Note\nThis diagnostic is not reported for arrays, since the compiler doesn't track array shape information.\n\nExample:\n\nfunction bounds_error(tpl::Tuple{Int})\n    return tpl[2]  # BoundsError: attempt to access Tuple{Int64} at index [2] (JETLS inference/bounds-error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/inference/method-error","page":"Diagnostic","title":"Method error (inference/method-error)","text":"Default severity: Warning\n\nFunction calls where no matching method can be found for the inferred argument types. This diagnostic detects potential MethodErrors that would occur at runtime.\n\nExamples:\n\nfunction method_error_example()\n    return sin(1, 2)  # no matching method found `sin(::Int64, ::Int64)` (JETLS inference/method-error)\nend\n\nWhen multiple union-split signatures fail to find matches, the diagnostic will report all failed signatures:\n\nonly_int(x::Int) = 2x\n\nfunction union_split_method_error(x::Union{Int,String})\n    return only_int(x)  # no matching method found `only_int(::String)` (1/2 union split)\n                        # (JETLS inference/method-error)\nend","category":"section"},{"location":"diagnostic/#diagnostic/reference/testrunner","page":"Diagnostic","title":"TestRunner diagnostic (testrunner/*)","text":"TestRunner diagnostics are reported when you manually run tests via code lens or code actions through the TestRunner integration (source: JETLS/extra). Unlike other diagnostics, these are not triggered automatically by editing or saving files.","category":"section"},{"location":"diagnostic/#diagnostic/reference/testrunner/test-failure","page":"Diagnostic","title":"Test failure (testrunner/test-failure)","text":"Default severity: Error\n\nTest failures reported by TestRunner integration that happened during running individual @testset blocks or @test cases.\n\nnote: Note\nDiagnostics from @test cases automatically disappear after 10 seconds, while @testset diagnostics persist until you run the testset again, restructure testsets, or clear them manually.","category":"section"},{"location":"diagnostic/#diagnostic/configuring","page":"Diagnostic","title":"Configuration","text":"You can configure which diagnostics are shown and at what severity level under the [diagnostic] section. This allows you to customize JETLS's behavior to match your project's coding standards and preferences.\n\nnothing # This is an internal comment for this documentaion: # hide\nnothing # Use H5 for subsections in this section so that the `@contents` block above works as intended. # hide","category":"section"},{"location":"diagnostic/#diagnostic/configuring/common-use-cases","page":"Diagnostic","title":"Common use cases","text":"Suppress specific macro expansion errors:\n\n[[diagnostic.patterns]]\npattern = \"Macro name `MyPkg.@mymacro` not found\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\nApply different settings for test files:\n\n# Downgrade unused arguments to hints in test files\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\npath = \"test/**/*.jl\"\n\n# Disable all diagnostics for generated code\n[[diagnostic.patterns]]\npattern = \".*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\npath = \"gen/**/*.jl\"\n\nDisable unused variable warnings during prototyping:\n\n[[diagnostic.patterns]]\npattern = \"lowering/(unused-argument|unused-local)\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\nMake inference diagnostic less intrusive:\n\n[[diagnostic.patterns]]\npattern = \"inference/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"hint\"\n\nFor complete configuration options, severity values, pattern matching syntax, and more examples, see the [diagnostic] configuration section in the JETLS configuration page.","category":"section"},{"location":"configuration/#JETLS-configuration","page":"Configuration","title":"JETLS configuration","text":"JETLS supports various configuration options. This documentation uses TOML format to describe the configuration schema.","category":"section"},{"location":"configuration/#config/schema","page":"Configuration","title":"Configuration schema","text":"formatter = \"Runic\"                # String preset: \"Runic\" (default) or \"JuliaFormatter\"\n\n[full_analysis]\ndebounce = 1.0                     # number (seconds), default: 1.0\nauto_instantiate = true            # boolean, default: true\n\n[formatter.custom]                 # Or custom formatter configuration\nexecutable = \"\"                    # string (path), optional\nexecutable_range = \"\"              # string (path), optional\n\n[diagnostic]\nenabled = true                     # boolean, default: true\nall_files = true                   # boolean, default: true\nallow_unused_underscore = false    # boolean, default: false\n\n[[diagnostic.patterns]]\npattern = \"\"                       # string, required\nmatch_by = \"\"                      # string, required, \"code\" or \"message\"\nmatch_type = \"\"                    # string, required, \"literal\" or \"regex\"\nseverity = \"\"                      # string or number, required, \"error\"/\"warning\"/\"warn\"/\"information\"/\"info\"/\"hint\"/\"off\" or 0/1/2/3/4\npath = \"\"                          # string (optional), glob pattern for file paths\n\n[completion.latex_emoji]\nstrip_prefix = false               # boolean, default: (unset) auto-detect\n\n[completion.method_signature]\nprepend_inference_result = false   # boolean, default: (unset) auto-detect\n\n[code_lens]\nreferences = false                 # boolean, default: false\ntestrunner = true                  # boolean, default: true\n\n[inlay_hint]\nblock_end_min_lines = 25           # integer, default: 25\n\n[testrunner]\nexecutable = \"testrunner\"          # string, default: \"testrunner\" (or \"testrunner.bat\" on Windows)","category":"section"},{"location":"configuration/#config/reference","page":"Configuration","title":"Configuration reference","text":"[full_analysis]\n[full_analysis] debounce\n[full_analysis] auto_instantiate\nformatter\n[diagnostic]\n[diagnostic] enabled\n[diagnostic] all_files\n[diagnostic] allow_unused_underscore\n[[diagnostic.patterns]]\n[completion]\n[completion.latex_emoji] strip_prefix\n[completion.method_signature] prepend_inference_result\n[code_lens]\n[code_lens] references\n[code_lens] testrunner\n[inlay_hint]\n[inlay_hint] block_end_min_lines\n[testrunner]\n[testrunner] executable","category":"section"},{"location":"configuration/#config/full_analysis","page":"Configuration","title":"[full_analysis]","text":"","category":"section"},{"location":"configuration/#config/full_analysis-debounce","page":"Configuration","title":"[full_analysis] debounce","text":"Type: number (seconds)\nDefault: 1.0\n\nDebounce time in seconds before triggering full analysis after a file save. JETLS performs type-aware analysis using JET.jl to detect potential errors. The debounce prevents excessive analysis when you save files frequently. Higher values reduce analysis frequency (saving CPU) but may delay diagnostic updates.\n\n[full_analysis]\ndebounce = 2.0  # Wait 2 seconds after save before analyzing","category":"section"},{"location":"configuration/#config/full_analysis-auto_instantiate","page":"Configuration","title":"[full_analysis] auto_instantiate","text":"Type: boolean\nDefault: true\n\nWhen enabled, JETLS automatically runs Pkg.resolve() and Pkg.instantiate() for packages that have not been instantiated yet (e.g., freshly cloned repositories). This allows full analysis to work immediately upon opening such packages. When no manifest file exists, JETLS first creates a versioned manifest (e.g., Manifest-v1.12.toml).\n\n[full_analysis]\nauto_instantiate = false  # Disable automatic instantiation","category":"section"},{"location":"configuration/#config/formatter","page":"Configuration","title":"formatter","text":"Type: string or table\nDefault: \"Runic\"\n\nFormatter configuration. Can be a preset name or a custom formatter object.\n\nPreset options:\n\n\"Runic\" (default): Uses Runic.jl (\"runic\" or \"runic.bat\" on Windows)\n\"JuliaFormatter\": Uses JuliaFormatter.jl (\"jlfmt\" or \"jlfmt.bat\" on Windows)\n\nCustom formatter configuration:\n\nformatter.custom.executable (string, optional): Path to custom formatter executable for document formatting. The formatter should read Julia code from stdin and output formatted code to stdout.\nformatter.custom.executable_range (string, optional): Path to custom formatter executable for range formatting. Should accept --lines=START:END argument.\n\nExamples:\n\n# Use JuliaFormatter preset\nformatter = \"JuliaFormatter\"\n\n# Or use custom formatter (both fields optional)\n[formatter.custom]\nexecutable = \"/path/to/custom-formatter\"\nexecutable_range = \"/path/to/custom-range-formatter\"\n\nSee Formatting for detailed configuration instructions and setup requirements.","category":"section"},{"location":"configuration/#config/diagnostic","page":"Configuration","title":"[diagnostic]","text":"Configure how JETLS reports diagnostic messages (errors, warnings, infos, hints) in your editor. JETLS uses hierarchical diagnostic codes in the format \"category/kind\" (following the LSP specification) to allow fine-grained control over which diagnostics to show and at what severity level.\n\nSee the Diagnostic section for complete diagnostic reference including all available codes, their meanings, and examples.","category":"section"},{"location":"configuration/#config/diagnostic-enabled","page":"Configuration","title":"[diagnostic] enabled","text":"Type: boolean\nDefault: true\n\nEnable or disable all JETLS diagnostics. When set to false, no diagnostic messages will be shown.\n\n[diagnostic]\nenabled = false  # Disable all diagnostics","category":"section"},{"location":"configuration/#config/diagnostic-all_files","page":"Configuration","title":"[diagnostic] all_files","text":"Type: boolean\nDefault: true\n\nEnable or disable diagnostics for unopened files. When enabled, JETLS reports diagnostics for all Julia files in the workspace. When disabled, diagnostics are only reported for files currently open in the editor.\n\nThis setting affects both JETLS/live and JETLS/save diagnostics. For JETLS/live, lowering-based analysis for unopened files is skipped when disabled (though the performance impact is minimal since lowering analysis is usually pretty fast). For JETLS/save, full analysis still runs; only reporting is suppressed. Disabling this can be useful to reduce noise when there are many warnings across the workspace.\n\n[diagnostic]\nall_files = false  # Disable diagnostics for unopened files","category":"section"},{"location":"configuration/#config/diagnostic-allow_unused_underscore","page":"Configuration","title":"[diagnostic] allow_unused_underscore","text":"Type: boolean\nDefault: true\n\nWhen enabled, unused variable diagnostics (lowering/unused-argument and lowering/unused-local) are suppressed for names starting with _ (underscore). This follows the common convention in many programming languages where _-prefixed names indicate intentionally unused variables.\n\n[diagnostic]\nallow_unused_underscore = false  # Report all unused variables","category":"section"},{"location":"configuration/#config/diagnostic-patterns","page":"Configuration","title":"[[diagnostic.patterns]]","text":"Fine-grained control over diagnostics through pattern matching against either diagnostic codes or messages.\n\nSee the diagnostic reference section for a complete list of all available diagnostic codes, their default severity levels, and detailed explanations with examples.","category":"section"},{"location":"configuration/#Configuration-syntax","page":"Configuration","title":"Configuration syntax","text":"Each pattern is defined as a table array entry with the following fields:\n\n[[diagnostic.patterns]]\npattern = \"pattern-value\"  # string: the pattern to match\nmatch_by = \"code\"          # string: \"code\" or \"message\"\nmatch_type = \"literal\"     # string: \"literal\" or \"regex\"\nseverity = \"hint\"          # string or number: severity level\npath = \"src/**/*.jl\"       # string (optional): restrict to specific files\n\npattern (Type: string): The pattern to match. For code matching, use diagnostic codes like \"lowering/unused-argument\". For message matching, use text patterns like \"Macro name .* not found\". This value is also used as the key when merging configurations from different sources.\nmatch_by (Type: string): What to match against\n\"code\": Match against diagnostic code (e.g., \"lowering/unused-argument\")\n\"message\": Match against diagnostic message text\nmatch_type (Type: string): How to interpret the pattern\n\"literal\": Exact string match\n\"regex\": Regular expression match\nseverity (Type: string or number): Severity level to apply\npath (Type: string, optional): Glob pattern to restrict this configuration to specific files. Patterns are matched against file paths relative to the workspace root. Supports globstar (**) for matching directories recursively. If omitted, the pattern applies to all files.","category":"section"},{"location":"configuration/#Severity-values","page":"Configuration","title":"Severity values","text":"Severity level to apply. Can be specified using either string or number values:\n\n\"error\" or 1: Critical issues that prevent code from working correctly\n\"warning\" or \"warn\" or 2: Potential problems that should be reviewed\n\"information\" or \"info\" or 3: Informational messages about code that may benefit from attention\n\"hint\" or 4: Suggestions for improvements or best practices\n\"off\" or 0: Disable the diagnostic\n\nString values are case-insensitive. The numeric values correspond to the LSP specification, while \"off\"/0 is a JETLS-specific extension for disabling diagnostics.","category":"section"},{"location":"configuration/#Pattern-matching-priority","page":"Configuration","title":"Pattern matching priority","text":"When multiple patterns match the same diagnostic, more specific patterns take precedence. The priority order (highest to lowest) is:\n\nmessage literal match\nmessage regex match\ncode literal match\ncode regex match\n\nThis priority strategy allows message-based patterns to override code-based patterns, enabling fine-grained control for specific diagnostic instances.\n\nExample showing priority:\n\n# Lower priority: matches all lowering diagnostics\n[[diagnostic.patterns]]\npattern = \"lowering/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"error\"\n\n# Higher priority: matches specific message\n[[diagnostic.patterns]]\npattern = \"Unused argument `x`\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n# Highest priority among code patterns: exact code match\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\n\nnote: Note\nWhen diagnostic.enabled is false, all diagnostics are disabled regardless of pattern settings.","category":"section"},{"location":"configuration/#[diagnostic]-configuration-examples","page":"Configuration","title":"[diagnostic] configuration examples","text":"[diagnostic]\nenabled = true\n\n# Pattern matching against diagnostic code\n[[diagnostic.patterns]]\npattern = \"lowering/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"warning\"\n\n# Disable inference diagnostic entirely\n[[diagnostic.patterns]]\npattern = \"inference/.*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\n# Show unused arguments as hints (overrides category setting)\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\n\n# Completely disable unused local variable diagnostics using integer value\n[[diagnostic.patterns]]\npattern = \"lowering/unused-local\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = 0\n\n# Pattern matching against diagnostic message\n[[diagnostic.patterns]]\npattern = \"Macro name `@interface` not found\"\nmatch_by = \"message\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n# Suppress all macro not found errors using regex\n[[diagnostic.patterns]]\npattern = \"Macro name `.*` not found\"\nmatch_by = \"message\"\nmatch_type = \"regex\"\nseverity = \"off\"\n\n# File path-based filtering: downgrade unused arguments in test files\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"hint\"\npath = \"test/**/*.jl\"\n\n# Disable all diagnostics for generated files\n[[diagnostic.patterns]]\npattern = \".*\"\nmatch_by = \"code\"\nmatch_type = \"regex\"\nseverity = \"off\"\npath = \"gen/**/*.jl\"\n\nSee the configuring diagnostics section for additional examples and common use cases.","category":"section"},{"location":"configuration/#config/completion","page":"Configuration","title":"[completion]","text":"Configure completion behavior.","category":"section"},{"location":"configuration/#config/completion-latex_emoji-strip_prefix","page":"Configuration","title":"[completion.latex_emoji] strip_prefix","text":"Type: boolean\nDefault: (unset) auto-detect based on client\n\nControls whether to strip the \\ or : prefix from LaTeX/emoji completion item labels.\n\nSome editors (e.g., Zed) don't handle backslash characters in the LSP sortText field, falling back to sorting by label. This can cause the expected completion item to not appear at the top when typing sequences like \\le for ≤.\n\nWhen set to true, JETLS strips the prefix from the label (e.g., \\le becomes le), allowing these editors to sort completions correctly.\n\nWhen set to false, JETLS keeps the full label with the prefix, which works correctly in editors (e.g., VSCode) that properly handle backslash characters in the sortText field.\n\nWhen not set (default), JETLS auto-detects based on the client name and applies the appropriate behavior. Note that the auto-detection only covers a limited set of known clients, so if you experience LaTeX/emoji completion sorting issues (e.g., expected items not appearing at the top), try explicitly setting this option.\n\n[completion.latex_emoji]\nstrip_prefix = true  # Force prefix stripping for clients with sortText issues\n\ntip: Help improve auto-detection\nIf explicitly setting this option clearly improves behavior for your client, consider submitting a PR to add your client to the auto-detection logic.","category":"section"},{"location":"configuration/#config/completion-method_signature-prepend_inference_result","page":"Configuration","title":"[completion.method_signature] prepend_inference_result","text":"Type: boolean\nDefault: (unset) auto-detect based on client\n\nControls whether to prepend inferred return type information to the documentation of method signature completion items.\n\nIn some editors (e.g., Zed), additional information like inferred return type displayed when an item is selected may be cut off in the UI when the method signature text is long.\n\nWhen set to true, JETLS prepends the return type as a code block to the documentation, ensuring it is always visible.\n\nWhen set to false, the return type is only shown alongside the completion item (as CompletionItem.detail in LSP terms, which may be cut off in some editors).\n\nWhen not set (default), JETLS auto-detects based on the client name and applies the appropriate behavior. Note that the auto-detection only covers a limited set of known clients, so if you experience issues with return type visibility, try explicitly setting this option.\n\n[completion.method_signature]\nprepend_inference_result = true  # Show return type in documentation\n\ntip: Help improve auto-detection\nIf explicitly setting this option clearly improves behavior for your client, consider submitting a PR to add your client to the auto-detection logic.","category":"section"},{"location":"configuration/#config/code_lens","page":"Configuration","title":"[code_lens]","text":"Configure code lens behavior.","category":"section"},{"location":"configuration/#config/code_lens-references","page":"Configuration","title":"[code_lens] references","text":"Type: boolean\nDefault: false\n\nShow reference counts for top-level symbols (functions, structs, constants, abstract types, primitive types, modules). When enabled, JETLS displays a code lens above each symbol showing how many times it is referenced in the codebase. Clicking the code lens opens the references panel.\n\n[code_lens]\nreferences = true  # Enable reference count code lenses","category":"section"},{"location":"configuration/#config/code_lens-testrunner","page":"Configuration","title":"[code_lens] testrunner","text":"Type: boolean\nDefault: true\n\nEnable or disable TestRunner code lenses. When enabled, JETLS shows \"Run\" and \"Debug\" code lenses above @testset blocks for running individual tests.\n\nSome editors (e.g., Zed[zed_code_lens_testrunner]) display code lenses as code actions, which can cause duplication when both code lenses and code actions are shown for the same functionality. In such cases, you may want to disable this setting.\n\n[zed_code_lens_testrunner]: The aviatesk/zed-julia extension defaults this setting to false unless explicitly configured.\n\n[code_lens]\ntestrunner = false  # Disable TestRunner code lenses","category":"section"},{"location":"configuration/#config/inlay_hint","page":"Configuration","title":"[inlay_hint]","text":"Configure inlay hint behavior.","category":"section"},{"location":"configuration/#config/inlay_hint-block_end_min_lines","page":"Configuration","title":"[inlay_hint] block_end_min_lines","text":"Type: integer\nDefault: 25\n\nMinimum number of lines a block must span before JETLS displays an inlay hint at its end keyword. Inlay hints show what construct is ending, such as module Foo, function foo or @testset \"foo\", helping navigate long blocks.\n\nSupported block types include module, function, macro, struct, if/@static if, let, for, while, and @testset.\n\n[inlay_hint]\nblock_end_min_lines = 10  # Show hints for blocks with 10+ lines","category":"section"},{"location":"configuration/#config/testrunner","page":"Configuration","title":"[testrunner]","text":"","category":"section"},{"location":"configuration/#config/testrunner-executable","page":"Configuration","title":"[testrunner] executable","text":"Type: string\nDefault: \"testrunner\" or \"testrunner.bat\" on Windows\n\nPath to the TestRunner.jl executable for running individual @testset blocks and @test cases.\n\n[testrunner]\nexecutable = \"/path/to/custom/testrunner\"\n\nSee TestRunner integration for setup instructions.","category":"section"},{"location":"configuration/#How-to-configure-JETLS","page":"Configuration","title":"How to configure JETLS","text":"","category":"section"},{"location":"configuration/#config/file-based-config","page":"Configuration","title":"Method 1: File-based configuration","text":"Create a .JETLSConfig.toml file in your project root. This configuration method works client-agnostically, thus allows projects to commit configuration to VCS without writing JETLS configurations in various formats that each client can understand.\n\nExample .JETLSConfig.toml:\n\n[full_analysis]\ndebounce = 2.0\n\n# Use JuliaFormatter instead of Runic\nformatter = \"JuliaFormatter\"\n\n# Suppress unused argument warnings\n[[diagnostic.patterns]]\npattern = \"lowering/unused-argument\"\nmatch_by = \"code\"\nmatch_type = \"literal\"\nseverity = \"off\"\n\n[testrunner]\nexecutable = \"/path/to/custom/testrunner\"","category":"section"},{"location":"configuration/#config/lsp-config","page":"Configuration","title":"Method 2: Editor configuration via LSP","text":"If your client supports workspace/configuration, you can configure JETLS in a client-specific manner. As examples, we show the configuration methods for the VSCode extension jetls-client, and the Zed extension aviatesk/zed-julia#avi/JETLS.","category":"section"},{"location":"configuration/#config/lsp-config/vscode","page":"Configuration","title":"VSCode (jetls-client extension)","text":"Configure JETLS in VSCode's settings.json file with jetls-client.settings section:\n\nExample .vscode/settings.json:\n\n{\n  \"jetls-client.settings\": {\n    \"full_analysis\": {\n      \"debounce\": 2.0\n    },\n    // Use JuliaFormatter instead of Runic\n    \"formatter\": \"JuliaFormatter\",\n    \"diagnostic\": {\n      \"patterns\": [\n        // Suppress toplevel/inference warnings in test folder\n        {\n          \"pattern\": \"(toplevel|inference)/.*\",\n          \"match_by\": \"code\",\n          \"match_type\": \"regex\",\n          \"severity\": \"off\",\n          \"path\": \"test/**/*.jl\"\n        }\n      ]\n    },\n    \"testrunner\": {\n      \"executable\": \"/path/to/custom/testrunner\"\n    }\n  }\n}\n\nSee package.json for the complete list of available VSCode settings and their descriptions.","category":"section"},{"location":"configuration/#config/lsp-config/zed","page":"Configuration","title":"Zed (aviatesk/zed-julia#avi/JETLS extension)","text":"Configure JETLS in Zed's settings.json file with the lsp.JETLS.settings section:\n\nExample .zed/settings.json:\n\n{\n  \"lsp\": {\n    \"JETLS\": {\n      \"settings\": {\n        \"full_analysis\": {\n          \"debounce\": 2.0\n        },\n        // Use JuliaFormatter instead of Runic\n        \"formatter\": \"JuliaFormatter\",\n        \"diagnostic\": {\n          \"patterns\": [\n            // Suppress toplevel/inference warnings in test folder\n            {\n              \"pattern\": \"(toplevel|inference)/.*\",\n              \"match_by\": \"code\",\n              \"match_type\": \"regex\",\n              \"severity\": \"off\",\n              \"path\": \"test/**/*.jl\"\n            }\n          ]\n        },\n        \"testrunner\": {\n          \"executable\": \"/path/to/custom/testrunner\"\n        }\n      }\n    }\n  }\n}","category":"section"},{"location":"configuration/#config/lsp-config/server-agnostic","page":"Configuration","title":"Server-agnostic clients (e.g., neovim, emacs lsp-mode, helix)","text":"Settings should be placed under the \"jetls\" key, such that a request for the \"jetls\" section produces an instance of the JETLS configuration schema. For example, neovim's built-in LSP client may be configured as follows:\n\nvim.lsp.config(\"jetls\", {\n  settings = {\n    jetls = {\n      full_analysis = {\n        debounce = 2.0,\n      },\n      -- Use JuliaFormatter instead of Runic\n      formatter = \"JuliaFormatter\",\n      diagnostic = {\n        patterns = [\n          -- Suppress toplevel/inference warnings in test folder\n          {\n            pattern = \"(toplevel|inference)/.*\",\n            match_by = \"code\",\n            match_type = \"regex\",\n            severity = \"off\",\n            path = \"test/**/*.jl\",\n          },\n        ],\n      },\n      testrunner = {\n        executable = \"/path/to/custom/testrunner\"\n      },\n    },\n  },\n})","category":"section"},{"location":"configuration/#config/priority","page":"Configuration","title":"Configuration priority","text":"When multiple configuration sources are present, they are merged in priority order (highest first):\n\nFile-based configuration (.JETLSConfig.toml)\nEditor configuration via LSP (workspace/configuration)\nBuilt-in defaults\n\nFile-based configuration (.JETLSConfig.toml) takes precedence as it provides a client-agnostic way to configure JETLS that works consistently across all editors.","category":"section"},{"location":"configuration/#config/merge","page":"Configuration","title":"Configuration merging","text":"For array-type configuration fields (such as diagnostic.patterns), entries from both LSP config and file config are merged rather than one completely overriding the other. Entries with same keys are merged with file config taking precedence, while entries unique to either source are preserved.","category":"section"},{"location":"#JETLS.jl-documentation","page":"Index","title":"JETLS.jl documentation","text":"The goal of this project is to develop a new language server for Julia, currently called \"JETLS\". JETLS aims to enhance developer productivity by providing advanced static analysis and seamless integration with the Julia runtime. By leveraging tooling technologies like JET.jl, JuliaSyntax.jl and JuliaLowering.jl, JETLS aims to offer enhanced language features such as type-sensitive diagnostic, macro-aware go-to definition and such.\n\nwarning: Experimental\nJETLS is under active development. Not production-ready; APIs and behavior may change. Stability and performance are limited. Expect bugs and rough edges.","category":"section"},{"location":"#Server-installation","page":"Index","title":"Server installation","text":"Editor clients for JETLS generally do not bundle the JETLS server itself. You need to install the jetls executable separately before using any editor integration.","category":"section"},{"location":"#Prerequisites","page":"Index","title":"Prerequisites","text":"JETLS requires Julia v\"1.12\" or higher (1.12.2+ recommended).","category":"section"},{"location":"#Installing-the-jetls-executable","page":"Index","title":"Installing the jetls executable","text":"All editor integrations require the jetls executable app, which is the main entry point for running JETLS.\n\nInstall it with:\n\njulia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'\n\nThis will install the jetls executable to ~/.julia/bin/. Make sure ~/.julia/bin is available on the PATH environment so the executable is accessible.\n\nYou can verify the installation by running:\n\njetls --help\n\nIf this displays the help message, the installation was successful and ~/.julia/bin is properly added to your PATH.\n\ninfo: Updating JETLS\nTo update JETLS to the latest version, re-run the installation command:julia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"release\")'To pin a specific version instead, use the release tag rev=\"YYYY-MM-DD\":julia -e 'using Pkg; Pkg.Apps.add(; url=\"https://github.com/aviatesk/JETLS.jl\", rev=\"2025-11-25\")'","category":"section"},{"location":"#Editor-setup","page":"Index","title":"Editor setup","text":"After installing the jetls executable, set up your editor to use it.","category":"section"},{"location":"#VSCode","page":"Index","title":"VSCode","text":"jetls-client is a VSCode client extension for JETLS.\n\nInstall the jetls-client extension from the VSCode Extensions marketplace (search for \"JETLS Client\" from the extensions view), then open any Julia file. The extension will automatically use the jetls executable from your PATH.\n\nFor advanced launching configurations and JETLS behavior settings, see the jetls-client README.\n\nnote: Note\nCurrently, JETLS.jl is not integrated with the julia-vscode extension. To use JETLS from VSCode, install the jetls-client extension. While we generally recommend disabling julia-vscode when using jetls-client, this is not required; you can use both julia-vscode and jetls-client in the same VSCode session. However, since the LSP features provided by JETLS.jl differ in both type and quality from those provided by julia-vscode's language server backend (LanguageServer.jl), you may encounter confusing situations where, for example, completion candidates are provided from different backends.","category":"section"},{"location":"#Emacs","page":"Index","title":"Emacs","text":"Minimal Emacs (eglot client) setup:\n\n(with-eval-after-load 'eglot\n  (add-to-list 'eglot-server-programs\n               '(((julia-mode :language-id \"julia\")\n                  (julia-ts-mode :language-id \"julia\"))\n                 \"jetls\"\n                 \"serve\"\n                 \"--socket\"\n                 :autoport)))","category":"section"},{"location":"#Vim","page":"Index","title":"Vim","text":"Minimal Vim setup using the Vim9 LSP plugin\n\ncall LspAddServer([#{name: 'JETLS.jl',\n                 \\   filetype: 'julia',\n                 \\   path: 'jetls',\n                 \\   args: [\n                 \\       'serve',\n                 \\   ]\n                 \\ }])","category":"section"},{"location":"#Neovim","page":"Index","title":"Neovim","text":"Minimal Neovim setup (requires Neovim v0.11):\n\nvim.lsp.config(\"jetls\", {\n    cmd = {\n        \"jetls\",\n        \"serve\",\n    },\n    filetypes = { \"julia\" },\n    root_markers = { \"Project.toml\" }\n})\nvim.lsp.enable(\"jetls\")","category":"section"},{"location":"#Sublime","page":"Index","title":"Sublime","text":"Minimal Sublime setup using the Sublime-LSP plugin and modifying the LSP.sublime-settings file:\n\n{\n  \"clients\": {\n    \"jetls\": {\n      \"enabled\": true,\n      \"command\": [\"jetls\", \"serve\", \"--socket=${port}\"],\n      \"selector\": \"source.julia\",\n      \"tcp_port\": 0\n    }\n  }\n}","category":"section"},{"location":"#Zed","page":"Index","title":"Zed","text":"Zed extension for Julia/JETLS is available: See aviatesk/zed-julia#avi/JETLS for the detailed installation steps.","category":"section"},{"location":"#Helix","page":"Index","title":"Helix","text":"Minimal Helix setup:\n\nlanguages.toml\n\n[[language]]\nname = \"julia\"\nlanguage-servers = [ \"jetls\" ]\n\n[language-server]\njetls = { command = \"jetls\", args = [\"serve\"] }","category":"section"},{"location":"#Advanced:-using-local-JETLS-checkout","page":"Index","title":"Advanced: using local JETLS checkout","text":"Advanced users can run JETLS directly from a local checkout by replacing the jetls executable with julia -m JETLS:\n\njulia --startup-file=no --project=/path/to/JETLS -m JETLS serve\n\nwarning: Warning\nWhen using a local checkout other than the release branch (e.g. master), JETLS dependencies may conflict with the dependencies of the code being analyzed. The release branch avoids this by vendoring dependencies with rewritten UUIDs.","category":"section"},{"location":"#Quick-links","page":"Index","title":"Quick links","text":"Pages = Main.quick_links_pages","category":"section"},{"location":"notebook/#notebook","page":"Notebook support","title":"Notebook support","text":"warning: Experimental\nNotebook support is experimental. The LSP specification for notebooks is still evolving, and jetls-client VS Code extension uses an unreleased version of vscode-languageclient to fully enable this feature.\n\nJETLS provides language features for Julia code cells in notebooks. The LSP notebook protocol is designed to be generic and can handle various notebook formats, but JETLS currently focuses on Jupyter notebooks given the current state of client implementations (see the Client support section below).","category":"section"},{"location":"notebook/#Demo","page":"Notebook support","title":"Demo","text":"<center>\n<video class=\"display-light-only\" style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/b5bb5201-d735-4a37-b430-932b519254ee\" type=\"video/mp4\">\n</video>\n<video class=\"display-dark-only\" style=\"width:100%;height:min(500px,70vh);aspect-ratio:16/9\" controls>\n  <source src=\"https://github.com/user-attachments/assets/f7476257-7a53-44a1-8c8c-1ad57e136a63\" type=\"video/mp4\">\n</video>\n</center>\n\nAs shown in this demo, all code cells are analyzed together as a single source, as if the notebook were a single Julia script. The language server is aware of all cells, so features like go-to-definition, completions, and diagnostics work across cells just as they would in a regular Julia script.","category":"section"},{"location":"notebook/#notebook/client-support","page":"Notebook support","title":"Client support","text":"As of December 2025, notebook LSP is only supported by VS Code and VS Code-based editors (such as Cursor, Eclipse Theia, or VS Codium).\n\nThese clients currently only support Jupyter notebooks (.ipynb files).\n\nOther editors like Neovim, Emacs, or Zed do not currently support the notebook LSP protocol, so this feature is not available in those environments.","category":"section"},{"location":"notebook/#notebook/usage","page":"Notebook support","title":"Usage","text":"Open a .ipynb file in VS Code\nSelect \"Julia\" as the notebook kernel/language\n\nThe notebook environment is detected automatically, just like for regular Julia scripts. If a Project.toml exists in the current or a parent directory, it will be used as the project environment.","category":"section"}]
}

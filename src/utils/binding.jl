# JuliaLowering also throws away this information in resolve_scopes.  Go
# backwards through lowering to seach for it.
function binding_scope_layer(ctx3, binding::JL.BindingInfo)
    st3 = JL.binding_ex(ctx3, binding.id)
    while get(st3, :source, nothing) isa JL.NodeId
        JL.hasattr(st3, :scope_layer) && return st3.scope_layer
        st3 = JL.SyntaxTree(JL.syntax_graph(st3), st3.source)
    end
    # JETLS_DEBUG_LOWERING && @warn "No scope layer found for binding" binding
    return 1
end

"""
Heuristic for showing completions.  A binding is relevant when all are true:
- it isn't generated by the compiler
- if nonglobal, it's defined before the cursor
- (if global) it doesn't contain or immediately precede the cursor
"""
function is_relevant(ctx3::JL.AbstractLoweringContext,
                     binding::JL.BindingInfo,
                     cursor::Int)
    (;start, stop) = JS.byte_range(JL.binding_ex(ctx3, binding.id))
    !binding.is_internal &&
        binding_scope_layer(ctx3, binding) === 1 && # hygiene: JL-expanded macros
        !contains(binding.name, '#') && # hygiene: manual gensyms
        !in(cursor, start:(stop+1)) &&
        (binding.kind === :global
         # || we could relax this for locals defined before the end of the
         #    largest for/while containing the cursor
         || cursor > start)
end

# Lowering doesn't really require the module apart from looking up macro names.
# If a feature takes a MaybeLoweringModule, most functionality will be present
# with mod=nothing.
const MaybeLoweringModule = Union{Module, Nothing}

module fallback_lowering_module end

"""
    jl_lower_for_scope_resolution(
            [mod::Module], st0::JL.SyntaxTree;
            trim_error_nodes::Bool = true,
            recover_from_macro_errors::Bool = true,
        ) -> (; st0, st1, st2, st3, ctx3)

Perform the first three passes of lowering.
Depending on keyword arguments, also attempt to handle junk input in the ways a language server should:
- `trim_error_nodes`: Trim parse errors from the tree beforehand.
- `recover_from_macro_errors`: If errors occur during macro expansion, trim macrocalls and retry.
  This may happen for several reasons; the analyzer may not have picked up the
  macro definition yet, or the user could be working on the macrocall.

Throw if lowering fails otherwise.

Note that ctx objects share mutable information, so we only return `ctx3`
"""
function jl_lower_for_scope_resolution(
        mod::Module, st0::JL.SyntaxTree;
        trim_error_nodes::Bool = true,
        recover_from_macro_errors::Bool = true,
    )
    if trim_error_nodes
        st0 = without_kinds(st0, JS.KSet"error")
    end
    ctx1, st1 = try
        JL.expand_forms_1(mod, st0)
    catch err
        recover_from_macro_errors || rethrow(err)
        JETLS_DEBUG_LOWERING && @warn "Error in macro expansion; trimming and retrying"
        JETLS_DEBUG_LOWERING && showerror(stderr, err)
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        st0 = without_kinds(st0, JS.KSet"macrocall")
        JL.expand_forms_1(mod, st0)
    end
    return _jl_lower_for_scope_resolution(ctx1, st0, st1)
end
function jl_lower_for_scope_resolution(st0::JL.SyntaxTree; kwargs...)
    JETLS_DEBUG_LOWERING && @warn "No lowering module provided; non-Base macrocalls may fail"
    return jl_lower_for_scope_resolution(fallback_lowering_module, st0; kwargs...)
end

function _jl_lower_for_scope_resolution(ctx1, st0, st1)
    ctx2, st2 = JL.expand_forms_2(ctx1, st1)
    ctx3, st3 = JL.resolve_scopes(ctx2, st2)
    return (; st0, st1, st2, st3, ctx3)
end

"""
Find the list of (BindingInfo, SyntaxTree, distance::Int) to suggest as
completions given a parsed SyntaxTree and a cursor position.

JuliaLowering throws away the mapping from scopes to bindings (scopes are stored
as an ephemeral stack.)  We work around this by taking all available bindings
and filtering out any that aren't declared in a scope containing the cursor.
"""
function cursor_bindings(st0_top::JL.SyntaxTree, b_top::Int, mod::Module)
    st0, b = @something greatest_local(st0_top, b_top) return nothing # nothing we can lower
    (; ctx3, st2) = try
        jl_lower_for_scope_resolution(mod, st0)
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing # lowering failed, e.g. because of incomplete input
    end

    # Note that ctx.bindings are only available after resolve_scopes, and
    # scope-blocks are not present in st3 after resolve_scopes.
    binfos = filter(binfo -> is_relevant(ctx3, binfo, b), ctx3.bindings.info)

    # for each binding: binfo, all syntaxtrees containing it, and the scope it belongs to
    bscopeinfos = Tuple{JL.BindingInfo, JL.SyntaxList, Union{JL.SyntaxTree, Nothing}}[]
    for binfo in binfos
        # TODO: find tree parents instead of byte parents?
        bas = byte_ancestors(st2, JS.byte_range(JL.binding_ex(ctx3, binfo.id)))
        # find the innermost hard scope containing this binding decl.  we shouldn't
        # be in multiple overlapping scopes that are not direct ancestors; that
        # should indicate a provenance failure
        i = findfirst(ba -> JS.kind(ba) in JS.KSet"scope_block lambda module toplevel", bas)
        push!(bscopeinfos, (binfo, bas, isnothing(i) ? nothing : bas[i]))
    end

    cursor_scopes = byte_ancestors(st2, b)

    # ignore scopes we aren't in
    filter!(((_, _, bs),) -> isnothing(bs) || bs._id in cursor_scopes.ids,
            bscopeinfos)

    # Now eliminate duplicates by name.
    # - Prefer any local binding belonging to a tighter scope (lower bdistance)
    # - If a static parameter and a local of the same name exist in the same
    #   scope (impossible in julia), the local is internal and should be ignored
    bdistances = map(((_, _, bs),) -> if isnothing(bs)
                         lastindex(cursor_scopes.ids) + 1
                     else
                         findfirst(cs -> bs._id === cs, cursor_scopes.ids)
                     end,
                     bscopeinfos)

    seen = Dict{String, Int}()
    for i in eachindex(bscopeinfos)
        (binfo, _, _) = bscopeinfos[i]

        prev = get(seen, binfo.name, nothing)
        if (isnothing(prev)
            || bdistances[i] < bdistances[prev]
            || binfo.kind === :static_parameter)
            seen[binfo.name] = i
        elseif JETLS_DEBUG_LOWERING
            @info "Found two bindings with the same name:" binfo bscopeinfos[prev][1]
        end
    end

    return map(values(seen)) do i
        (binfo, _, _) = bscopeinfos[i]
        # distance from the cursor
        dist = abs(b - JS.last_byte(JL.binding_ex(ctx3, binfo.id)))
        return (binfo, JL.binding_ex(ctx3, binfo.id), dist)
    end
end

function __select_target_binding(ctx3::JL.VariableAnalysisContext, st3::JL.SyntaxTree, offset::Int)
    function select(st::JL.SyntaxTree)
        JS.kind(st) === JS.K"BindingId" || return false
        binfo = JL.lookup_binding(ctx3, st)
        return !binfo.is_internal
    end

    bas = byte_ancestors(st3, offset)
    i = findfirst(select, bas)
    if isnothing(i)
        offset > 0 || return nothing
        # Support cases like `var│`, `func│(5)`
        bas = byte_ancestors(st3, offset - 1)
        i = findfirst(select, bas)
        if isnothing(i)
            return nothing
        end
    end
    return bas[i]
end

function _select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    st0, b = @something greatest_local(st0_top, offset) return nothing # nothing we can lower

    bas = byte_ancestors(st0, offset)
    macname_i = findfirst(ba->JS.kind(ba)===JS.K"MacroName", bas)
    if !isnothing(macname_i)
        # Our definition generally won't be local, and lowering would destroy it
        # anyway.  Defer to global logic.
        return nothing
    end

    (; ctx3, st3) = try
        jl_lower_for_scope_resolution(mod, st0)
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing
    end
    binding = @something __select_target_binding(ctx3, st3, b) return nothing
    return (; ctx3, st3, binding)
end

"""
    select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module) -> target_binding::Union{Nothing,JL.SyntaxTree}

For the same purpose as [`select_target_node`](@ref), returns the `target_binding::JL.SyntaxTree`
closest to the cursor at the `offset` position.
It is guaranteed that `target_binding` satisfies `JS.kind(target_binding) === JS.K"BindingId"`.
"""
function select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    (; binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    return binding
end

"""
    select_target_binding_definitions(st0_top::JL.SyntaxTree, offset::Int, mod::Module) ->
        nothing or (binding::JL.SyntaxTree, definitions::JL.SyntaxList)

Find the binding at the cursor position and return all of its definition sites.

Returns `nothing` if lowering fails, no binding is found at the cursor, or the binding
has no definitions. Otherwise returns a tuple of `(binding, definitions)` where:
- `binding` is the `JL.SyntaxTree` node representing the binding at the cursor
- `definitions` is a `JL.SyntaxList` containing all definition sites for that binding
"""
function select_target_binding_definitions(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    (; ctx3, st3, binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    binfo = JL.lookup_binding(ctx3, binding)
    definitions = lookup_binding_definitions(st3, binfo)
    isempty(definitions) && return nothing
    return binding, definitions
end

is_same_binding(x::JL.SyntaxTree, id::Int) = JS.kind(x) === JS.K"BindingId" && id == JL._binding_id(x)

"""
    lookup_binding_definitions(st3::JL.SyntaxTree, binfo::JL.BindingInfo) -> definitions::JL.SyntaxList

Find all definition sites for a given binding in the syntax tree. Returns a `JL.SyntaxList`
containing the syntax nodes where the binding may be defined.

This function traverses the syntax tree to collect `definitions` that tracks all the
assignment expressions (`=`) and function declarations where the binding may be defined.
For `:argument` bindings, `definitions` also includes the argument declaration itself.
"""
function lookup_binding_definitions(st3::JL.SyntaxTree, binfo::JL.BindingInfo)
    if binfo.kind === :argument
        sl = JL.SyntaxList(JL.syntax_graph(st3), [binfo.node_id])
    else
        sl = JL.SyntaxList(st3)
    end
    return _lookup_binding_definitions!(sl, st3, binfo.id)
end

function _lookup_binding_definitions!(sl::JL.SyntaxList, st3::JL.SyntaxTree, binding_id::Int)
    traverse(st3) do st::JL.SyntaxTree
        if JS.kind(st) === JS.K"=" && JS.numchildren(st) ≥ 2
            lhs = st[1]
            if is_same_binding(lhs, binding_id)
                push!(sl, lhs)
            end
        elseif JS.kind(st) === JS.K"function_decl" && JS.numchildren(st) ≥ 1
            func = st[1]
            if is_same_binding(func, binding_id)
                push!(sl, func)
            end
        end
    end
    return reverse!(deduplicate_syntaxlist(sl))
end

struct BindingOccurence{Tree3<:JL.SyntaxTree}
    tree::Tree3
    kind::Symbol
end

"""
    compute_binding_occurrences(
            ctx3::JL.VariableAnalysisContext, st3::Tree3;
            ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing
        ) where Tree3<:JL.SyntaxTree
        -> binding_occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}}

Analyze a lowered syntax tree to find all occurrences of local and argument bindings.

This function traverses the syntax tree `st3` and records `occurrence::BindingOccurence`s
for each local and argument binding within `st3`, where `occurrence` have the following
information:
- `occurrence.tree::JL.SyntaxTree`: Syntax tree for this occurrence of the binding
- `occurrence.kind::Symbol`
  - `:decl` - explicit declarations like `local x`
  - `:def` - assignments or function arguments
  - `:use` - references to the binding

# Arguments
- `ctx3`: Variable analysis context from JuliaLowering containing binding information
- `st3`: Lowered syntax tree (after scope resolution) to analyze
- `ismacro`: Optional mutable reference to track if any function binding is a macro

# Returns
`binding_occurrences` is a dictionary mapping each non-internal local/argument binding to
a set of `BindingOccurence` objects that record where and how the binding appears.

!!! note "Comparison with `select_target_binding_definitions`"
    While [`select_target_binding_definitions`](@ref) traces definitions from a specific use
    point (cursor position), `compute_binding_occurrences` is a more general routine that
    analyzes all bindings in the entire syntax tree. Use this function when you need
    comprehensive information about binding declarations and uses, such as for unused
    variable diagnostics or comprehensive binding analysis.
"""
function compute_binding_occurrences(
        ctx3::JL.VariableAnalysisContext, st3::Tree3;
        ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing
    ) where Tree3<:JL.SyntaxTree
    occurrences = Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}}()

    # group together argument bindings with the same name
    same_arg_bindings = Dict{Symbol,Vector{Int}}()

    for (i, binfo) = enumerate(ctx3.bindings.info)
        binfo.is_internal && continue
        if binfo.kind === :argument
            push!(get!(Vector{Int}, same_arg_bindings, Symbol(binfo.name)), i)
        elseif binfo.kind !== :local
            continue
        end
        occurrences[binfo] = Set{BindingOccurence{Tree3}}()
    end

    if !isempty(occurrences)
        compute_binding_occurrences!(occurrences, ctx3, st3; ismacro)

        # Fix up usedness information of arguments that are only used within the argument list.
        # E.g. this is necessary to avoid reporting "unused variable diagnostics" for `a` in cases like:
        # ```julia
        # hasmatch(x::RegexMatch, y::Bool=isempty(x.matches)) = y
        # ```
        for (_, idxs) in same_arg_bindings
            newoccurrences = union!((occurrences[ctx3.bindings.info[idx]] for idx in idxs)...)
            for idx in idxs
                occurrences[ctx3.bindings.info[idx]] = newoccurrences
            end
        end
    end

    return occurrences
end

function record_occurrence!(occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        kind::Symbol, st::Tree3, ctx3::JL.VariableAnalysisContext;
        skip_recording::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    if JS.kind(st) === JS.K"BindingId"
        binfo = JL.lookup_binding(ctx3, st)
        record_occurrence!(occurrences, kind, st, binfo; skip_recording)
    end
    return occurrences
end

function record_occurrence!(occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        kind::Symbol, st::Tree3, binfo::JL.BindingInfo;
        skip_recording::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    if haskey(occurrences, binfo) && (binfo ∉ @something skip_recording ())
        push!(occurrences[binfo], BindingOccurence(st, kind))
    end
    return occurrences
end

function compute_binding_occurrences!(
        occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        ctx3::JL.VariableAnalysisContext, st3::Tree3;
        ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing,
        include_decls::Bool = false,
        skip_recording_uses::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    stack = JL.SyntaxList(st3)
    push!(stack, st3)
    infunc = false
    while !isempty(stack)
        st = pop!(stack)
        k = JS.kind(st)
        n = JS.numchildren(st)
        if k === JS.K"local" # || k === JS.K"function_decl"
            if n ≥ 1
                record_occurrence!(occurrences, :decl, st[1], ctx3)
                if !include_decls
                    continue # avoid to recurse to skip recording use
                end
            end
        end

        if k === JS.K"BindingId"
            record_occurrence!(occurrences, :use, st, ctx3; skip_recording=skip_recording_uses)
        end

        i = 1
        if k === JS.K"function_decl"
            infunc = true
            if n ≥ 1
                local func = st[1]
                if JS.kind(func) === JS.K"BindingId"
                    binfo = JL.lookup_binding(ctx3, func)
                    record_occurrence!(occurrences, :decl, func, binfo)
                    if !isnothing(ismacro)
                        ismacro[] |= startswith(binfo.name, "@")
                    end
                end
            end
        elseif infunc && k === JS.K"block" && n ≥ 1
            blk1 = st[1]
            if JS.kind(blk1) === JS.K"function_decl" && infunc && JS.numchildren(blk1) ≥ 1
                # This is an inner function definition -- the binding of this inner function
                # is "used" in the language constructs required to define the method,
                # but what we're interested in is whether it's actually used in the outer scope.
                # We add this inner function to `skip_recording_uses` and recurse.
                local func = blk1[1]
                if JS.kind(func) === JS.K"BindingId"
                    innerfuncinfo = JL.lookup_binding(ctx3, func)
                    compute_binding_occurrences!(occurrences, ctx3, st; ismacro,
                        skip_recording_uses = Set((innerfuncinfo,)))
                    continue
                end
            end
        elseif k === JS.K"lambda"
            i = 2 # the first block, i.e. the argument declaration does not account for usage
            if n ≥ 1
                arglist = st[1]
                na = JS.numchildren(arglist)
                for i = 1:na
                    record_occurrence!(occurrences, :def, arglist[i], ctx3)
                end
                is_kwcall = na ≥ 3 &&
                    JS.kind(arglist[1]) === JS.K"BindingId" &&
                    let arg1info = JL.lookup_binding(ctx3, arglist[1])
                        arg1info.is_internal && arg1info.name == "#self#"
                    end &&
                    JS.kind(arglist[2]) === JS.K"BindingId" &&
                    let arg2info = JL.lookup_binding(ctx3, arglist[2])
                        arg2info.is_internal && arg2info.name == "kws"
                    end &&
                    JS.kind(arglist[3]) === JS.K"BindingId" &&
                    let arg3info = JL.lookup_binding(ctx3, arglist[3])
                        arg3info.is_internal && (arg3info.name == "#self#" || arg3info.name == "#ctor-self#")
                    end
                if is_kwcall
                    # This is `kwcall` method -- now need to perform some special case
                    # Julia checks whether keyword arguments are assigned in `kwcall` methods,
                    # but JL actually introduces local bindings for those keyword arguments for reflection purposes:
                    # https://github.com/c42f/JuliaLowering.jl/blob/4b12ab19dad40c64767558be0a8a338eb4cc9172/src/desugaring.jl#L2633-L2637
                    # These bindings are never actually used, so simply recursing would cause
                    # this pass to report them as unused local bindings.
                    # We avoid this problem by setting `include_decls` when recursing.
                    for j = 1:n
                        compute_binding_occurrences!(occurrences, ctx3, st[j]; ismacro, include_decls=true)
                    end
                    continue
                end
            end
        elseif k === JS.K"="
            i = 2 # the left hand side, i.e. "definition", does not account for usage
            if n ≥ 1
                record_occurrence!(occurrences, :def, st[1], ctx3)
                if n ≥ 2
                    rhs = st[2]
                    # In struct definitions, `local struct_name` is somehow introduced,
                    # so special case it here: https://github.com/c42f/JuliaLowering.jl/blob/4b12ab19dad40c64767558be0a8a338eb4cc9172/src/desugaring.jl#L3833
                    # TODO investigate why this local binding introduction is necessary on the JL side
                    if JS.kind(rhs) === JS.K"BindingId" && JL.lookup_binding(ctx3, rhs).name == "struct_type"
                        i = 1
                    end
                end
            end
        elseif k === JS.K"call" && n ≥ 1
            arg1 = st[1]
            if JS.kind(arg1) === JS.K"BindingId" && JL.lookup_binding(ctx3, arg1).name == "#self#"
                # Don't count self arguments used in self calls as "usage".
                # This is necessary to issue unused argument diagnostics for `x` in cases like:
                # ```julia
                # hasmatch(x::RegexMatch, y::Bool=false) = nothing
                # ```
                for j = n:-1:2 # reversed since we use `pop!`
                    argⱼ = st[j]
                    if JS.kind(argⱼ) === JS.K"BindingId" && JL.lookup_binding(ctx3, argⱼ).kind === :argument
                        continue # skip this argument
                    end
                    push!(stack, st[j])
                end
                push!(stack, arg1)
                continue
            end
        end
        for j = n:-1:i # reversed since we use `pop!`
            push!(stack, st[j])
        end
    end

    return occurrences, ismacro
end

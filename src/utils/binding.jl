# JuliaLowering also throws away this information in resolve_scopes.  Go
# backwards through lowering to seach for it.
function binding_scope_layer(ctx3, binding::JL.BindingInfo)
    st3 = JL.binding_ex(ctx3, binding.id)
    while get(st3, :source, nothing) isa JL.NodeId
        JL.hasattr(st3, :scope_layer) && return st3.scope_layer
        st3 = JL.SyntaxTree(JL.syntax_graph(st3), st3.source)
    end
    # JETLS_DEBUG_LOWERING && @warn "No scope layer found for binding" binding
    return 1
end

"""
Heuristic for showing completions.  A binding is relevant when all are true:
- it isn't generated by the compiler
- if nonglobal, it's defined before the cursor
- (if global) it doesn't contain or immediately precede the cursor
"""
function is_relevant(ctx3::JL.AbstractLoweringContext,
                     binding::JL.BindingInfo,
                     cursor::Int)
    (;start, stop) = JS.byte_range(JL.binding_ex(ctx3, binding.id))
    !binding.is_internal &&
        binding_scope_layer(ctx3, binding) === 1 && # hygiene: JL-expanded macros
        !contains(binding.name, '#') && # hygiene: manual gensyms
        !in(cursor, start:(stop+1)) &&
        (binding.kind === :global
         # || we could relax this for locals defined before the end of the
         #    largest for/while containing the cursor
         || cursor > start)
end

"""
    jl_lower_for_scope_resolution(
            mod::Module, st0::JL.SyntaxTree;
            trim_error_nodes::Bool = true,
            recover_from_macro_errors::Bool = true,
        ) -> (; st0, st1, st2, st3, ctx3)

Perform the first three passes of lowering.
Depending on keyword arguments, also attempt to handle junk input in the ways a language server should:
- `trim_error_nodes`: Trim parse errors from the tree beforehand.
- `recover_from_macro_errors`: If errors occur during macro expansion, trim macrocalls and retry.
  This may happen for several reasons; the analyzer may not have picked up the
  macro definition yet, or the user could be working on the macrocall.

Throw if lowering fails otherwise.

Note that ctx objects share mutable information, so we only return `ctx3`
"""
function jl_lower_for_scope_resolution(
        mod::Module, st0::JL.SyntaxTree;
        trim_error_nodes::Bool = true,
        recover_from_macro_errors::Bool = true,
    )
    if trim_error_nodes
        st0 = without_kinds(st0, JS.KSet"error")
    end
    ctx1, st1 = try
        JL.expand_forms_1(mod, st0, true, Base.get_world_counter())
    catch err
        recover_from_macro_errors || rethrow(err)
        JETLS_DEBUG_LOWERING && @warn "Error in macro expansion; trimming and retrying"
        JETLS_DEBUG_LOWERING && showerror(stderr, err)
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        st0 = without_kinds(st0, JS.KSet"macrocall")
        JL.expand_forms_1(mod, st0, true, Base.get_world_counter())
    end
    return _jl_lower_for_scope_resolution(ctx1, st0, st1)
end

function _jl_lower_for_scope_resolution(ctx1, st0, st1)
    ctx2, st2 = JL.expand_forms_2(ctx1, st1)
    ctx3, st3 = JL.resolve_scopes(ctx2, st2)
    return (; st0, st1, st2, st3, ctx3)
end

"""
Find the list of (BindingInfo, SyntaxTree, distance::Int) to suggest as
completions given a parsed SyntaxTree and a cursor position.

JuliaLowering throws away the mapping from scopes to bindings (scopes are stored
as an ephemeral stack.)  We work around this by taking all available bindings
and filtering out any that aren't declared in a scope containing the cursor.
"""
function cursor_bindings(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    st0 = @something greatest_local(st0_top, offset) return nothing # nothing we can lower
    (; ctx3, st2) = try
        jl_lower_for_scope_resolution(mod, st0)
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing # lowering failed, e.g. because of incomplete input
    end

    # Note that ctx.bindings are only available after resolve_scopes, and
    # scope-blocks are not present in st3 after resolve_scopes.
    binfos = filter(binfo -> is_relevant(ctx3, binfo, offset), ctx3.bindings.info)

    # for each binding: binfo, all syntaxtrees containing it, and the scope it belongs to
    bscopeinfos = Tuple{JL.BindingInfo, Union{JL.SyntaxTree, Nothing}}[]
    for binfo in binfos
        # TODO: find tree parents instead of byte parents?
        bas = byte_ancestors(st2, JS.byte_range(JL.binding_ex(ctx3, binfo.id))) do st2′::JL.SyntaxTree
            # find the innermost hard scope containing this binding decl.  we shouldn't
            # be in multiple overlapping scopes that are not direct ancestors; that
            # should indicate a provenance failure
            JS.kind(st2′) in JS.KSet"scope_block lambda module toplevel"
        end
        push!(bscopeinfos, (binfo, isempty(bas) ? nothing : first(bas)))
    end

    cursor_scopes = byte_ancestors(st2, offset)

    # ignore scopes we aren't in
    filter!(((_, bs),) -> isnothing(bs) || bs._id in cursor_scopes.ids,
            bscopeinfos)

    # Now eliminate duplicates by name.
    # - Prefer any local binding belonging to a tighter scope (lower bdistance)
    # - If a static parameter and a local of the same name exist in the same
    #   scope (impossible in julia), the local is internal and should be ignored
    bdistances = map(((_, bs),) -> if isnothing(bs)
                         lastindex(cursor_scopes.ids) + 1
                     else
                         findfirst(cs -> bs._id === cs, cursor_scopes.ids)
                     end,
                     bscopeinfos)

    seen = Dict{String, Int}()
    for i in eachindex(bscopeinfos)
        (binfo, _) = bscopeinfos[i]

        prev = get(seen, binfo.name, nothing)
        if (isnothing(prev)
            || bdistances[i] < bdistances[prev]
            || binfo.kind === :static_parameter)
            seen[binfo.name] = i
        elseif JETLS_DEBUG_LOWERING
            @info "Found two bindings with the same name:" binfo bscopeinfos[prev][1]
        end
    end

    return map(values(seen)) do i
        (binfo, _) = bscopeinfos[i]
        # distance from the cursor
        dist = abs(offset - JS.last_byte(JL.binding_ex(ctx3, binfo.id)))
        return (binfo, JL.binding_ex(ctx3, binfo.id), dist)
    end
end

function find_target_binding(ctx3::JL.VariableAnalysisContext, st3::JL.SyntaxTree, offset::Int)
    target_binding = nothing
    traverse(st3) do st::JL.SyntaxTree
        k = JS.kind(st)
        if k === JS.K"lambda" && is_kwcall_lambda(ctx3, st)
            # Don't select a binding with `kwcall` definition.
            # What usually interesting to us is information about the main method.
            return TraversalNoRecurse()
        end
        offset in JS.byte_range(st) || return nothing
        k === JS.K"BindingId" || return nothing
        binfo = JL.lookup_binding(ctx3, st)
        if binfo.is_internal || startswith(binfo.name, "#")
            return nothing
        end
        target_binding = st
    end
    return target_binding
end

__select_target_binding(ctx3::JL.VariableAnalysisContext, st3::JL.SyntaxTree, offset::Int) =
    @something(
        find_target_binding(ctx3, st3, offset),
        find_target_binding(ctx3, st3, offset-1), # Support cases like `var│`, `func│(5)`
        return nothing)

function _select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module;
                                caller::AbstractString = "_select_target_binding")
    st0 = @something greatest_local(st0_top, offset) return nothing # nothing we can lower

    bas = byte_ancestors(st0′::JL.SyntaxTree->JS.kind(st0′) in JS.KSet"macrocall", st0, offset)
    if !isempty(bas) && offset in JS.byte_range(bas[1][1])
        # In macrocall first arg.  Our definition can't be local, and lowering
        # would destroy it anyway.  Defer to global logic.
        return nothing
    end

    (; ctx3, st3) = try
        # Remove macros to preserve precise source locations
        jl_lower_for_scope_resolution(mod, remove_macrocalls(st0))
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering ($caller)" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing
    end
    binding = @something __select_target_binding(ctx3, st3, offset) return nothing
    return (; ctx3, st3, binding)
end

"""
    select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module) -> target_binding::Union{Nothing,JL.SyntaxTree}

For the same purpose as [`select_target_node`](@ref), returns the `target_binding::JL.SyntaxTree`
closest to the cursor at the `offset` position.
It is guaranteed that `target_binding` satisfies `JS.kind(target_binding) === JS.K"BindingId"`.
"""
function select_target_binding(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    (; binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    return binding
end

"""
    select_target_binding_definitions(st0_top::JL.SyntaxTree, offset::Int, mod::Module) ->
        nothing or (binding::JL.SyntaxTree, definitions::JL.SyntaxList)

Find the binding at the cursor position and return all of its definition sites.

Returns `nothing` if lowering fails, no binding is found at the cursor, or the binding
has no definitions. Otherwise returns a tuple of `(binding, definitions)` where:
- `binding` is the `JL.SyntaxTree` node representing the binding at the cursor
- `definitions` is a `JL.SyntaxList` containing all definition sites for that binding
"""
function select_target_binding_definitions(st0_top::JL.SyntaxTree, offset::Int, mod::Module)
    (; ctx3, st3, binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    binfo = JL.lookup_binding(ctx3, binding)
    definitions = lookup_binding_definitions(st3, binfo)
    isempty(definitions) && return nothing
    return binding, definitions
end

is_same_binding(x::JL.SyntaxTree, id::Int) = JS.kind(x) === JS.K"BindingId" && id == JL._binding_id(x)

is_local_binding(binfo::JL.BindingInfo) =
    binfo.kind === :argument || binfo.kind === :static_parameter || binfo.kind === :local

"""
    lookup_binding_definitions(st3::JL.SyntaxTree, binfo::JL.BindingInfo) -> definitions::JL.SyntaxList

Find all definition sites for a given binding in the syntax tree. Returns a `JL.SyntaxList`
containing the syntax nodes where the binding may be defined.

This function traverses the syntax tree to collect `definitions` that tracks all the
assignment expressions (`=`) and function declarations where the binding may be defined.
For `:argument` or `:static_parameter` bindings, `definitions` also includes the argument
or static parameter declaration itself.
"""
function lookup_binding_definitions(st3::JL.SyntaxTree, binfo::JL.BindingInfo)
    if binfo.kind === :argument || binfo.kind === :static_parameter
        sl = JL.SyntaxList(JL.syntax_graph(st3), [binfo.node_id])
    else
        sl = JL.SyntaxList(st3)
    end
    return _lookup_binding_definitions!(sl, st3, binfo.id)
end

function _lookup_binding_definitions!(sl::JL.SyntaxList, st3::JL.SyntaxTree, binding_id::Int)
    traverse(st3) do st::JL.SyntaxTree
        if JS.kind(st) in JS.KSet"= kw" && JS.numchildren(st) ≥ 2
            lhs = st[1]
            if is_same_binding(lhs, binding_id)
                push!(sl, lhs)
            end
        elseif JS.kind(st) === JS.K"function_decl" && JS.numchildren(st) ≥ 1
            func = st[1]
            if is_same_binding(func, binding_id)
                push!(sl, func)
            end
        end
    end
    return reverse!(deduplicate_syntaxlist(sl))
end

struct BindingOccurence{Tree3<:JL.SyntaxTree}
    tree::Tree3
    kind::Symbol
end

"""
    compute_binding_occurrences(
            ctx3::JL.VariableAnalysisContext, st3::Tree3;
            ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing
        ) where Tree3<:JL.SyntaxTree
        -> binding_occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}}

Analyze a lowered syntax tree to find all occurrences of local and argument bindings.

This function traverses the syntax tree `st3` and records `occurrence::BindingOccurence`s
for each local and argument binding within `st3`, where `occurrence` have the following
information:
- `occurrence.tree::JL.SyntaxTree`: Syntax tree for this occurrence of the binding
- `occurrence.kind::Symbol`
  - `:decl` - explicit declarations like `local x`
  - `:def` - assignments or function arguments
  - `:use` - references to the binding

# Arguments
- `ctx3`: Variable analysis context from JuliaLowering containing binding information
- `st3`: Lowered syntax tree (after scope resolution) to analyze
- `ismacro`: Optional mutable reference to track if any function binding is a macro

# Returns
`binding_occurrences` is a dictionary mapping each non-internal local/argument binding to
a set of `BindingOccurence` objects that record where and how the binding appears.

!!! note "Comparison with `select_target_binding_definitions`"
    While [`select_target_binding_definitions`](@ref) traces definitions from a specific use
    point (cursor position), `compute_binding_occurrences` is a more general routine that
    analyzes all bindings in the entire syntax tree. Use this function when you need
    comprehensive information about binding declarations and uses, such as for unused
    variable diagnostics or comprehensive binding analysis.
"""
function compute_binding_occurrences(
        ctx3::JL.VariableAnalysisContext, st3::Tree3;
        ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing,
        include_global_bindings::Bool = false
    ) where Tree3<:JL.SyntaxTree
    occurrences = Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}}()

    same_arg_bindings = Dict{Symbol,Vector{Int}}() # group together argument bindings with the same name
    same_location_bindings = Dict{Tuple{Symbol,Int,Int},Vector{Int}}() # group together local bindings with the same location and name

    for (i, binfo) = enumerate(ctx3.bindings.info)
        binfo.is_internal && continue
        if binfo.kind === :argument
            push!(get!(Vector{Int}, same_arg_bindings, Symbol(binfo.name)), i)
        elseif binfo.kind === :static_parameter || binfo.kind === :local
            lockey = (Symbol(binfo.name), JS.source_location(JL.binding_ex(ctx3, binfo.id))...)
            push!(get!(Vector{Int}, same_location_bindings, lockey), i)
        elseif binfo.kind === :global
            include_global_bindings || continue
        else
            error(lazy"Unknown binding kind: $(binfo.kind)")
        end
        occurrences[binfo] = Set{BindingOccurence{Tree3}}()
    end

    isempty(occurrences) && return occurrences

    compute_binding_occurrences!(occurrences, ctx3, st3; ismacro)

    # Aggregate occurrences for bindings that have the same name and location.
    # JL sometimes represents bindings that are considered "identical" at the source level
    # as multiple copies for the sake of the actual semantics of the lowered code.
    # Therefore, such aggregation is necessary to map occurrences in the lowered representation
    # to usage information at the source level.
    for (_, idxs) in same_location_bindings
        length(idxs) == 1 && continue
        newoccurrences = union!((occurrences[ctx3.bindings.info[idx]] for idx in idxs)...)
        for idx in idxs
            occurrences[ctx3.bindings.info[idx]] = newoccurrences
        end
    end

    # Fix up usedness information of arguments that are only used within the argument list.
    # to avoid reporting "unused variable diagnostics" for `x` in cases like:
    # ```julia
    # hasmatch(x::RegexMatch, y::Bool=isempty(x.matches)) = y
    # ```
    # N.B. This needs to be done separately from `same_location_bindings`.
    # This is because if argument lists were also aggregated by "name & location" key,
    # then even when `x` is truly unused, the usage in methods that fill default parameters
    # and call the full-argument list method would be aggregated, causing us to miss reports
    # in such cases, e.g.
    # ```julia
    # hasmatch(x::RegexMatch, y::Bool=false) = nothing
    # ```
    for (_, idxs) in same_arg_bindings
        length(idxs) == 1 && continue
        newoccurrences = union!((occurrences[ctx3.bindings.info[idx]] for idx in idxs)...)
        for idx in idxs
            occurrences[ctx3.bindings.info[idx]] = newoccurrences
        end
    end

    return occurrences
end

function record_occurrence!(occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        kind::Symbol, st::Tree3, ctx3::JL.VariableAnalysisContext;
        skip_recording::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    if JS.kind(st) === JS.K"BindingId"
        binfo = JL.lookup_binding(ctx3, st)
        record_occurrence!(occurrences, kind, st, binfo; skip_recording)
    end
    return occurrences
end

function record_occurrence!(occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        kind::Symbol, st::Tree3, binfo::JL.BindingInfo;
        skip_recording::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    if haskey(occurrences, binfo) && (binfo ∉ @something skip_recording ())
        push!(occurrences[binfo], BindingOccurence(st, kind))
    end
    return occurrences
end

function is_kwcall_lambda(ctx3::JL.VariableAnalysisContext, st3::JL.SyntaxTree)
    @assert JS.kind(st3) === JS.K"lambda" "Expected `lambda` kind"
    JS.numchildren(st3) ≥ 1 || return false
    arglist = st3[1]
    na = JS.numchildren(arglist)
    return na ≥ 3 &&
        JS.kind(arglist[1]) === JS.K"BindingId" &&
        let arg1info = JL.lookup_binding(ctx3, arglist[1])
            arg1info.is_internal && arg1info.name == "#self#"
        end &&
        JS.kind(arglist[2]) === JS.K"BindingId" &&
        let arg2info = JL.lookup_binding(ctx3, arglist[2])
            arg2info.is_internal && arg2info.name == "kws"
        end &&
        JS.kind(arglist[3]) === JS.K"BindingId" &&
        let arg3info = JL.lookup_binding(ctx3, arglist[3])
            arg3info.is_internal && (arg3info.name == "#self#" || arg3info.name == "#ctor-self#")
        end
end

function compute_binding_occurrences!(
        occurrences::Dict{JL.BindingInfo,Set{BindingOccurence{Tree3}}},
        ctx3::JL.VariableAnalysisContext, st3::Tree3;
        ismacro::Union{Nothing,Base.RefValue{Bool}} = nothing,
        include_decls::Bool = false,
        skip_recording_uses::Union{Nothing,Set{JL.BindingInfo}} = nothing
    ) where Tree3<:JL.SyntaxTree
    stack = JL.SyntaxList(st3)
    push!(stack, st3)
    infunc = false
    while !isempty(stack)
        st = pop!(stack)
        k = JS.kind(st)
        nc = JS.numchildren(st)
        if k === JS.K"local" # || k === JS.K"function_decl"
            if nc ≥ 1
                record_occurrence!(occurrences, :decl, st[1], ctx3)
                if !include_decls
                    continue # avoid to recurse to skip recording use
                end
            end
        end

        if k === JS.K"BindingId"
            record_occurrence!(occurrences, :use, st, ctx3; skip_recording=skip_recording_uses)
        end

        start_idx = 1
        if k === JS.K"function_decl"
            infunc = true
            if nc ≥ 1
                local func = st[1]
                if JS.kind(func) === JS.K"BindingId"
                    binfo = JL.lookup_binding(ctx3, func)
                    record_occurrence!(occurrences, :decl, func, binfo)
                    if !isnothing(ismacro)
                        ismacro[] |= startswith(binfo.name, "@")
                    end
                    start_idx = 2
                end
            end
        elseif k === JS.K"method_defs" || k === JS.K"constdecl"
            if nc ≥ 1
                local global_binding = st[1]
                if JS.kind(global_binding) === JS.K"BindingId"
                    binfo = JL.lookup_binding(ctx3, global_binding)
                    record_occurrence!(occurrences, :def, global_binding, binfo)
                    start_idx = 2
                end
            end
        elseif infunc && k === JS.K"block" && nc ≥ 1
            blk1 = st[1]
            if JS.kind(blk1) === JS.K"function_decl" && infunc && JS.numchildren(blk1) ≥ 1
                # This is an inner function definition -- the binding of this inner function
                # is "used" in the language constructs required to define the method,
                # but what we're interested in is whether it's actually used in the outer scope.
                # We add this inner function to `skip_recording_uses` and recurse.
                local func = blk1[1]
                if JS.kind(func) === JS.K"BindingId"
                    innerfuncinfo = JL.lookup_binding(ctx3, func)
                    compute_binding_occurrences!(occurrences, ctx3, st; ismacro,
                        skip_recording_uses = Set((innerfuncinfo,)))
                    continue
                end
            end
        elseif k === JS.K"lambda"
            # All blocks except the last one define arguments and static parameters,
            # so we recurse to avoid counting them as usage
            if nc ≥ 2
                arglist = st[1]
                for i = 1:JS.numchildren(arglist)
                    record_occurrence!(occurrences, :def, arglist[i], ctx3)
                end
                start_idx = 2
                if nc ≥ 3
                    sparamlist = st[2]
                    for i = 1:JS.numchildren(sparamlist)
                        record_occurrence!(occurrences, :def, sparamlist[i], ctx3)
                    end
                    start_idx = 3
                end
                if is_kwcall_lambda(ctx3, st)
                    # This is `kwcall` method -- now need to perform some special case
                    # Julia checks whether keyword arguments are assigned in `kwcall` methods,
                    # but JL actually introduces local bindings for those keyword arguments for reflection purposes:
                    # https://github.com/c42f/JuliaLowering.jl/blob/4b12ab19dad40c64767558be0a8a338eb4cc9172/src/desugaring.jl#L2633-L2637
                    # These bindings are never actually used, so simply recursing would cause
                    # this pass to report them as unused local bindings.
                    # We avoid this problem by setting `include_decls` when recursing.
                    for i = 1:nc
                        compute_binding_occurrences!(occurrences, ctx3, st[i]; ismacro, include_decls=true)
                    end
                    continue
                end
            end
        elseif k === JS.K"="
            start_idx = 2 # the left hand side, i.e. "definition", does not account for usage
            if nc ≥ 1
                record_occurrence!(occurrences, :def, st[1], ctx3)
                if nc ≥ 2
                    rhs = st[2]
                    # In struct definitions, `local struct_name` is somehow introduced,
                    # so special case it here: https://github.com/c42f/JuliaLowering.jl/blob/4b12ab19dad40c64767558be0a8a338eb4cc9172/src/desugaring.jl#L3833
                    # TODO investigate why this local binding introduction is necessary on the JL side
                    if JS.kind(rhs) === JS.K"BindingId" && JL.lookup_binding(ctx3, rhs).name == "struct_type"
                        start_idx = 1
                    end
                end
            end
        elseif k === JS.K"call" && nc ≥ 1
            arg1 = st[1]
            if JS.kind(arg1) === JS.K"BindingId" && JL.lookup_binding(ctx3, arg1).name == "#self#"
                # Don't count self arguments used in self calls as "usage".
                # This is necessary to issue unused argument diagnostics for `x` in cases like:
                # ```julia
                # hasmatch(x::RegexMatch, y::Bool=false) = nothing
                # ```
                for i = nc:-1:2 # reversed since we use `pop!`
                    argⱼ = st[i]
                    if JS.kind(argⱼ) === JS.K"BindingId" && JL.lookup_binding(ctx3, argⱼ).kind === :argument
                        continue # skip this argument
                    end
                    push!(stack, st[i])
                end
                push!(stack, arg1)
                continue
            end
        end
        for i = nc:-1:start_idx # reversed since we use `pop!`
            push!(stack, st[i])
        end
    end

    return occurrences, ismacro
end

function find_global_binding_occurrences!(
        state::ServerState, uri::URI, fi::FileInfo, st0_top::JL.SyntaxTree,
        binfo::JL.BindingInfo;
        lookup_func = gen_lookup_out_of_scope!(state, uri)
    )
    ret = Set{BindingOccurence}()
    iterate_toplevel_tree(st0_top) do st0::JL.SyntaxTree
        (; mod) = get_context_info(state, uri, offset_to_xy(fi, JS.first_byte(st0)); lookup_func)
        (; ctx3, st3) = try
            # Remove macros to preserve precise source locations
            jl_lower_for_scope_resolution(mod, remove_macrocalls(st0))
        catch
            return
        end
        binding_occurrences = compute_binding_occurrences(ctx3, st3; include_global_bindings=true)
        for (binfo′, occurrences) in binding_occurrences
            if binfo′.mod === binfo.mod && binfo′.name == binfo.name
                for occurrence in occurrences
                    push!(ret, occurrence)
                end
            end
        end
    end
    return ret
end

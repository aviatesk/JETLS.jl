# JuliaLowering also throws away this information in resolve_scopes.  Go
# backwards through lowering to seach for it.
function binding_scope_layer(ctx3, binding::JL.BindingInfo)
    st3 = JL.binding_ex(ctx3, binding.id)
    while get(st3, :source, nothing) isa JS.NodeId
        JS.hasattr(st3, :scope_layer) && return st3.scope_layer
        st3 = JS.SyntaxTree(JS.syntax_graph(st3), st3.source)
    end
    # JETLS_DEBUG_LOWERING && @warn "No scope layer found for binding" binding
    return 1
end

"""
Heuristic for showing completions.  A binding is relevant when all are true:
- it isn't generated by the compiler
- if nonglobal, it's defined before the cursor
- (if global) it doesn't contain or immediately precede the cursor
"""
function is_relevant(ctx3::JL.AbstractLoweringContext,
                     binding::JL.BindingInfo,
                     cursor::Int)
    (;start, stop) = JS.byte_range(JL.binding_ex(ctx3, binding.id))
    !binding.is_internal &&
        binding_scope_layer(ctx3, binding) === 1 && # hygiene: JL-expanded macros
        !contains(binding.name, '#') && # hygiene: manual gensyms
        !in(cursor, start:(stop+1)) &&
        (binding.kind === :global
         # || we could relax this for locals defined before the end of the
         #    largest for/while containing the cursor
         || cursor > start)
end

"""
    jl_lower_for_scope_resolution(
            mod::Module, st0::JS.SyntaxTree;
            trim_error_nodes::Bool = true,
            recover_from_macro_errors::Bool = true,
            convert_closures::Bool = false,
        ) -> (; st0, st1, st2, st3, ctx3)

Perform the first three passes of lowering.
Depending on keyword arguments, also attempt to handle junk input in the ways a language server should:
- `trim_error_nodes`: Trim parse errors from the tree beforehand.
- `recover_from_macro_errors`: If errors occur during macro expansion, trim macrocalls and retry.
  This may happen for several reasons; the analyzer may not have picked up the
  macro definition yet, or the user could be working on the macrocall.

Throw if lowering fails otherwise.

Note that ctx objects share mutable information, so we only return `ctx3`
"""
function jl_lower_for_scope_resolution(
        mod::Module, st0::JS.SyntaxTree, world::UInt = Base.get_world_counter();
        trim_error_nodes::Bool = true,
        recover_from_macro_errors::Bool = true,
        convert_closures::Bool = false,
    )
    if trim_error_nodes
        st0 = without_kinds(st0, JS.KSet"error")
    end
    ctx1, st1 = try
        JL.expand_forms_1(mod, st0, true, world)
    catch err
        recover_from_macro_errors || rethrow(err)
        JETLS_DEBUG_LOWERING && @warn "Error in macro expansion; trimming and retrying"
        JETLS_DEBUG_LOWERING && showerror(stderr, err)
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        st0 = without_kinds(st0, JS.KSet"macrocall")
        JL.expand_forms_1(mod, st0, true, world)
    end
    return _jl_lower_for_scope_resolution(ctx1, st0, st1; convert_closures)
end

function _jl_lower_for_scope_resolution(ctx1, st0, st1; convert_closures::Bool = false)
    ctx2, st2 = JL.expand_forms_2(ctx1, st1)
    ctx3, st3 = JL.resolve_scopes(ctx2, st2)
    convert_closures || return (; st0, st1, st2, st3, ctx3)
    ctx4, st4 = JL.convert_closures(ctx3, st3)
    return (; st0, st1, st2, st3, st4, ctx3, ctx4)
end

"""
Find the list of (BindingInfo, SyntaxTree, distance::Int) to suggest as
completions given a parsed SyntaxTree and a cursor position.

JuliaLowering throws away the mapping from scopes to bindings (scopes are stored
as an ephemeral stack.)  We work around this by taking all available bindings
and filtering out any that aren't declared in a scope containing the cursor.
"""
function cursor_bindings(st0_top::JS.SyntaxTree, offset::Int, mod::Module)
    st0 = @something greatest_local(st0_top, offset) return nothing # nothing we can lower
    (; ctx3, st2) = try
        jl_lower_for_scope_resolution(mod, st0)
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing # lowering failed, e.g. because of incomplete input
    end

    # Note that ctx.bindings are only available after resolve_scopes, and
    # scope-blocks are not present in st3 after resolve_scopes.
    binfos = filter(binfo -> is_relevant(ctx3, binfo, offset), ctx3.bindings.info)

    # for each binding: binfo, all syntaxtrees containing it, and the scope it belongs to
    bscopeinfos = Tuple{JL.BindingInfo, Union{JS.SyntaxTree, Nothing}}[]
    for binfo in binfos
        # TODO: find tree parents instead of byte parents?
        bas = byte_ancestors(st2, JS.byte_range(JL.binding_ex(ctx3, binfo.id))) do st2′::JS.SyntaxTree
            # find the innermost hard scope containing this binding decl.  we shouldn't
            # be in multiple overlapping scopes that are not direct ancestors; that
            # should indicate a provenance failure
            JS.kind(st2′) in JS.KSet"scope_block lambda module toplevel"
        end
        push!(bscopeinfos, (binfo, isempty(bas) ? nothing : first(bas)))
    end

    cursor_scopes = byte_ancestors(st2, offset)

    # ignore scopes we aren't in
    filter!(((_, bs),) -> isnothing(bs) || bs._id in cursor_scopes.ids,
            bscopeinfos)

    # Now eliminate duplicates by name.
    # - Prefer any local binding belonging to a tighter scope (lower bdistance)
    # - If a static parameter and a local of the same name exist in the same
    #   scope (impossible in julia), the local is internal and should be ignored
    bdistances = map(((_, bs),) -> if isnothing(bs)
                         lastindex(cursor_scopes.ids) + 1
                     else
                         findfirst(cs -> bs._id === cs, cursor_scopes.ids)
                     end,
                     bscopeinfos)

    seen = Dict{String, Int}()
    for i in eachindex(bscopeinfos)
        (binfo, _) = bscopeinfos[i]

        prev = get(seen, binfo.name, nothing)
        if (isnothing(prev)
            || bdistances[i] < bdistances[prev]
            || binfo.kind === :static_parameter)
            seen[binfo.name] = i
        elseif JETLS_DEBUG_LOWERING
            @info "Found two bindings with the same name:" binfo bscopeinfos[prev][1]
        end
    end

    return map(values(seen)) do i
        (binfo, _) = bscopeinfos[i]
        # distance from the cursor
        dist = abs(offset - JS.last_byte(JL.binding_ex(ctx3, binfo.id)))
        return (binfo, JL.binding_ex(ctx3, binfo.id), dist)
    end
end

function find_target_binding(ctx3::JL.VariableAnalysisContext, st3::JS.SyntaxTree, offset::Int)
    return traverse(st3) do st::JS.SyntaxTree
        k = JS.kind(st)
        if k === JS.K"lambda" && is_kwcall_lambda(ctx3, st)
            # Don't select a binding with `kwcall` definition.
            # What usually interesting to us is information about the main method.
            return TraversalNoRecurse()
        end
        offset in JS.byte_range(st) || return nothing
        k === JS.K"BindingId" || return nothing
        binfo = JL.get_binding(ctx3, st)
        if binfo.is_internal || startswith(binfo.name, "#")
            return nothing
        end
        return TraversalReturn(st)
    end
end

function is_kwcall_lambda(ctx3::JL.VariableAnalysisContext, st3::JS.SyntaxTree)
    @assert JS.kind(st3) === JS.K"lambda" "Expected `lambda` kind"
    JS.numchildren(st3) ≥ 1 || return false
    arglist = st3[1]
    na = JS.numchildren(arglist)
    return na ≥ 3 &&
        JS.kind(arglist[1]) === JS.K"BindingId" &&
        let arg1info = JL.get_binding(ctx3, arglist[1])
            arg1info.is_internal && arg1info.name == "#self#"
        end &&
        JS.kind(arglist[2]) === JS.K"BindingId" &&
        let arg2info = JL.get_binding(ctx3, arglist[2])
            arg2info.is_internal && arg2info.name == "kws"
        end &&
        JS.kind(arglist[3]) === JS.K"BindingId" &&
        let arg3info = JL.get_binding(ctx3, arglist[3])
            arg3info.is_internal && (arg3info.name == "#self#" || arg3info.name == "#ctor-self#")
        end
end

__select_target_binding(ctx3::JL.VariableAnalysisContext, st3::JS.SyntaxTree, offset::Int) =
    @something(
        find_target_binding(ctx3, st3, offset),
        find_target_binding(ctx3, st3, offset-1), # Support cases like `var│`, `func│(5)`
        return nothing)

function _select_target_binding(st0_top::JS.SyntaxTree, offset::Int, mod::Module;
                                caller::AbstractString = "_select_target_binding")
    st0 = @something greatest_local(st0_top, offset) return nothing # nothing we can lower

    macrocall_result = select_macrocall_binding(st0, offset, mod, caller)
    macrocall_result !== nothing && return macrocall_result

    (; ctx3, st3) = try
        # Remove macros to preserve precise source locations
        jl_lower_for_scope_resolution(mod, remove_macrocalls(st0))
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering ($caller)" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing
    end
    binding = @something __select_target_binding(ctx3, st3, offset) return nothing
    return (; ctx3, st3, binding)
end

function select_macrocall_binding(
        st0::JS.SyntaxTree, offset::Int, mod::Module, caller::AbstractString
    )
    is_macrocall_name = (offset::Int) -> (st0′::JS.SyntaxTree) ->
        JS.kind(st0′) === JS.K"macrocall" && JS.numchildren(st0′) ≥ 1 &&
        offset in JS.byte_range(st0′[1])
    bas = byte_ancestors(is_macrocall_name(offset), st0, offset)
    if isempty(bas)
        # Support cases like `@macro│` where cursor is at the end
        offset -= 1
        bas = byte_ancestors(is_macrocall_name(offset), st0, offset)
    end
    isempty(bas) && return nothing
    macrocall_name = bas[1][1]
    (; ctx3, st3) = try
        jl_lower_for_scope_resolution(mod, macrocall_name)
    catch err
        JETLS_DEBUG_LOWERING && @warn "Error in lowering ($caller)" err
        JETLS_DEBUG_LOWERING && Base.show_backtrace(stderr, catch_backtrace())
        return nothing
    end
    for binfo in ctx3.bindings.info
        binding = JL.binding_ex(ctx3, binfo)
        if offset in JS.byte_range(binding)
            return (; ctx3, st3, binding)
        end
    end
    return nothing
end

"""
    select_target_binding(st0_top::JS.SyntaxTree, offset::Int, mod::Module) -> target_binding::Union{Nothing,JS.SyntaxTree}

For the same purpose as [`select_target_identifier`](@ref), returns the `target_binding::JS.SyntaxTree`
closest to the cursor at the `offset` position.
It is guaranteed that `target_binding` satisfies `JS.kind(target_binding) === JS.K"BindingId"`.
"""
function select_target_binding(st0_top::JS.SyntaxTree, offset::Int, mod::Module)
    (; binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    return binding
end

"""
    select_target_binding_definitions(st0_top::JS.SyntaxTree, offset::Int, mod::Module) ->
        nothing or (binding::JS.SyntaxTree, definitions::JS.SyntaxList)

Find the binding at the cursor position and return all of its definition sites.

Returns `nothing` if lowering fails, no binding is found at the cursor, or the binding
has no definitions. Otherwise returns a tuple of `(binding, definitions)` where:
- `binding` is the `JS.SyntaxTree` node representing the binding at the cursor
- `definitions` is a `JS.SyntaxList` containing all definition sites for that binding
"""
function select_target_binding_definitions(st0_top::JS.SyntaxTree, offset::Int, mod::Module)
    (; ctx3, st3, binding) = @something _select_target_binding(st0_top, offset, mod) return nothing
    binfo = JL.get_binding(ctx3, binding)
    definitions = @somereal lookup_binding_definitions(st3, binfo) return nothing
    return binding, definitions
end

is_same_binding(x::JS.SyntaxTree, id::Int) = JS.kind(x) === JS.K"BindingId" && id == JL._binding_id(x)

is_local_binding(binfo::JL.BindingInfo) =
    binfo.kind === :argument || binfo.kind === :static_parameter || binfo.kind === :local

"""
    lookup_binding_definitions(st3::JS.SyntaxTree, binfo::JL.BindingInfo) -> definitions::JS.SyntaxList

Find all definition sites for a given binding in the syntax tree. Returns a `JS.SyntaxList`
containing the syntax nodes where the binding may be defined.

This function traverses the syntax tree to collect `definitions` that tracks all the
assignment expressions (`=`) and function declarations where the binding may be defined.
For `:argument` or `:static_parameter` bindings, `definitions` also includes the argument
or static parameter declaration itself.
"""
function lookup_binding_definitions(st3::JS.SyntaxTree, binfo::JL.BindingInfo)
    if binfo.kind === :argument || binfo.kind === :static_parameter
        sl = JS.SyntaxList(JS.syntax_graph(st3), [binfo.node_id])
    else
        sl = JS.SyntaxList(st3)
    end
    return _lookup_binding_definitions!(sl, st3, binfo.id)
end

function _lookup_binding_definitions!(sl::JS.SyntaxList, st3::JS.SyntaxTree, binding_id::Int)
    traverse(st3) do st::JS.SyntaxTree
        if JS.kind(st) in JS.KSet"= kw" && JS.numchildren(st) ≥ 2
            lhs = st[1]
            if is_same_binding(lhs, binding_id)
                push!(sl, lhs)
            end
        elseif JS.kind(st) === JS.K"function_decl" && JS.numchildren(st) ≥ 1
            func = st[1]
            if is_same_binding(func, binding_id)
                push!(sl, func)
            end
        end
    end
    return reverse!(deduplicate_syntaxlist(sl))
end
